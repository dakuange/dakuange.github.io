<script type="text/javascript">
<!--// Init menu
actionsMenuInit('更多操作：');
//-->
</script>
</form>
</li></ul>

</div>

<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><p class="line867">
<h1 id="A.2BW55OYGXli7A-">实习日记</h1>
<span class="anchor" id="line-2"></span><p class="line867"><strong>猿辅导-初高中服务器B端研发实习生-陈宽</strong> <span class="anchor" id="line-3"></span><span class="anchor" id="line-4"></span><p class="line867"><div class="table-of-contents"><p class="table-of-contents-heading">目录<ol><li>
<a href="#A.2BW55OYGXli7A-">实习日记</a><ol><li>
<a href="#play_ground_task_1">play ground task 1</a><ol><li>
<a href="#logic_.26.26_service">logic &amp;&amp; service</a></li><li>
<a href="#RPC_.26.26_REST">RPC &amp;&amp; REST</a></li></ol></li><li>
<a href="#May_30">May 30</a><ol><li>
<a href="#RestController">RestController</a></li><li>
<a href="#Mac_.2BUXOV7XrvU.2BM-">Mac 关闭端口</a></li><li>
<a href="#A.2BZXBjbg-VO_.2BdoRPf3UoVzpmbw-">数据VO 的使用场景</a></li><li>
<a href="#A.2BUXNOjg-Test">关于Test</a></li><li>
<a href="#Rest_.2BT391KInEgwM-">Rest 使用规范</a></li></ol></li><li>
<a href="#May_31">May 31</a><ol><li>
<a href="#DataNotFoundException">DataNotFoundException</a></li><li>
<a href="#A.2BWJ5SoFtXa7U-Optional">增加字段Optional</a></li><li>
<a href="#Mac_.2BU4ZT8lR9TuQ_.2BYwdO5A-">Mac 历史命令 指令</a></li></ol></li><li>
<a href="#June_4">June 4</a><ol><li>
<a href="#Query_.2BdoROJHnNZblfDw-">Query 的两种方式</a></li></ol></li><li>
<a href="#June_5">June 5</a><ol><li>
<a href="#A.2BW4lRaIO3U9Y-userId.2Be0llcGNu-">安全获取userId等数据</a></li><li>
<a href="#online.2BUgZlLw_.2BVAhedmTNT1w-">online分支 合并操作</a></li><li>
<a href="#DB_.2BZS9jAZicZYdbVw-">DB 支持颜文字</a></li><li>
<a href="#A.2BmHl27pDof3JtQXoL-">项目部署流程</a></li></ol></li><li>
<a href="#June_06">June 06</a><ol><li>
<a href="#A.2BenpQPHaEUiRlrVSMj9RW3g-">空值的判断和返回</a></li><li>
<a href="#A.2BenpQPFIkZa0-">空值判断</a></li><li>
<a href="#A.2Bj9RW3np6UDw-">返回空值</a></li></ol></li><li>
<a href="#June_09">June 09</a><ol><li>
<a href="#A.2BW.2FxR.2Bg-CSV">导出CSV</a></li></ol></li><li>
<a href="#June_10">June 10</a></li><li>
<a href="#June_11">June 11</a><ol><li>
<a href="#A.2BW.2FxlcFJnj8d6Cw-">导数剧过程</a></li></ol></li><li>
<a href="#June_12">June 12</a></li><li>
<a href="#June_13">June 13</a><ol><li>
<a href="#git_.2BW2ZOYA-">git 学习</a></li><li>
<a href="#git_merge">git merge</a></li><li>
<a href="#git_rebase">git rebase</a></li><li>
<a href="#git_reset">git reset</a></li></ol></li><li>
<a href="#June_14">June 14</a><ol><li>
<a href="#jsonCreater">jsonCreater</a></li></ol></li><li>
<a href="#June_16">June 16</a><ol><li>
<a href="#A.2BfxNbWGVwY25ek04AgfRgJ5XumJg_callback.2BieNRsw-">缓存数据库一致性问题 callback解决</a></li></ol></li><li>
<a href="#June_19">June 19</a><ol><li>
<a href="#Episode">Episode</a></li></ol></li><li>
<a href="#June_20">June 20</a><ol><li>
<a href="#Charles">Charles</a></li></ol></li><li>
<a href="#June_21">June 21</a><ol><li>
<a href="#A.2BZyxXMHOvWINeOHUoU8JlcJFNf24-">本地环境常用参数配置</a></li><li>
<a href="#Git_Cherry_Pick_.2BZM1PXA-">Git Cherry Pick 操作</a></li><li>
<a href="#A.2BUiR6eg_.2BVIw_.2BUgZrtYv7U9Y-">判空 和 分段读取</a></li></ol></li><li>
<a href="#June_22">June 22</a></li><li>
<a href="#June_25">June 25</a></li><li>
<a href="#June_26">June 26</a></li><li>
<a href="#June_27">June 27</a><ol><li>
<a href="#A.2BW2ZOYG4FdAZnDVKh-">学习清理服务</a></li></ol></li><li>
<a href="#June_28_.26_29">June 28 &amp; 29</a><ol><li>
<a href="#A.2BfSJfFQ_ES">索引 ES</a></li></ol></li><li>
<a href="#July_2">July 2</a><ol><li>
<a href="#cache_key">cache key</a></li></ol></li><li>
<a href="#July_3">July 3</a></li><li>
<a href="#July_4">July 4</a></li><li>
<a href="#July_5">July 5</a></li><li>
<a href="#July_6">July 6</a></li><li>
<a href="#July_9_.26.26_July_10">July 9 &amp;&amp; July 10</a></li><li>
<a href="#July_11">July 11</a></li><li>
<a href="#July_12">July 12</a><ol><li>
<a href="#git_reset_.2BTgl5zQ-">git reset 三种</a></li><li>
<a href="#A.2BZbByW1tmTmA---Git.2B.2Fww-MVN.2B.2Fww-shell">新牛学习--Git，MVN，shell</a></li></ol></li><li>
<a href="#July_13">July 13</a></li><li>
<a href="#July_14">July 14</a></li><li>
<a href="#July_15">July 15</a><ol><li>
<a href="#A.2BZbByWw---Java">新牛--Java</a></li></ol></li><li>
<a href="#July_17">July 17</a><ol><li>
<a href="#git_.2BT.2B5lOU5LUk1j0E6kj8d2hFGFW7k-">git 修改之前提交过的内容</a></li><li>
<a href="#shell">shell</a></li></ol></li><li>
<a href="#July_18">July 18</a><ol><li>
<a href="#Test_.2BXA9XUQ-">Test 小坑</a></li></ol></li><li>
<a href="#July_19">July 19</a><ol><li>
<a href="#A.2BZbByW1tmTmA---JVM_.2BbfFRZU6GieM-">新牛学习--JVM 深入了解</a></li></ol></li><li>
<a href="#July_20">July 20</a><ol><li>
<a href="#A.2BlsZPU1tmTmA_JVM.2BjANPGA-">集体学习 JVM调优</a></li></ol></li><li>
<a href="#July_21-26">July 21-26</a><ol><li>
<a href="#Redis_.2BThpSoVtmTmA-">Redis 业务学习</a></li><li>
<a href="#New-Bull_.2BXnZT0X8Wegt1MW1FUWVt8Q-">New-Bull 并发编程由浅入深</a></li><li>
<a href="#A.2Bfud.2B7Q-Tutor-team_.2BThpSoWV0dAY-">继续Tutor-team 业务整理</a></li></ol></li><li>
<a href="#July_29">July 29</a><ol><li>
<a href="#A.2BTgNZKU4Di.2B2KAA-">七天七语言</a></li></ol></li><li>
<a href="#July_31">July 31</a><ol><li>
<a href="#A.2BZw1SoWV0dAY-">服务整理</a></li></ol></li><li>
<a href="#Aug_1">Aug 1</a><ol><li>
<a href="#A.2BW2ZOYA-redis.2BdvhRc3UobNU-">学习redis相关用法</a></li></ol></li><li>
<a href="#Aug_2">Aug 2</a><ol><li>
<a href="#A.2BZbByW1tmTmA_--_.2Bi76LoWVwY25bxpbGV4telHUo-">新牛学习 -- 设计数据密集型应用</a></li><li>
<a href="#A.2Bfud.2B7Q-tutor-team.2BZw1SoWV0dAb.2FDGXgV1E-">继续tutor-team服务整理，无坑</a></li></ol></li><li>
<a href="#Aug_3">Aug 3</a><ol><li>
<a href="#A.2BW.2FxR.2Bouoi7pTOmXlX9c-">导出讨论区日志</a></li><li>
<a href="#A.2BeyxOAGshdTOL9w-redis">第一次申请redis</a></li></ol></li><li>
<a href="#Aug_4">Aug 4</a><ol><li>
<a href="#A.2BW2ZOYIu.2Bi6FlcGNuW8aWxleLXpR1KA-">学习设计数据密集型应用</a></li></ol></li></ol></li><li>
<a href="#A.2BW55OYGA7ftM-">实习总结</a></li></ol></div> <span class="anchor" id="line-5"></span><span class="anchor" id="line-6"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-7"></span>
<h2 id="play_ground_task_1">play ground task 1</h2>
<span class="anchor" id="line-8"></span><p class="line867">
<h3 id="logic_.26.26_service">logic &amp;&amp; service</h3>
<span class="anchor" id="line-9"></span><p class="line874">* Logic层和Service层有什么区别？Logic 处理数据，调用service , Service 调用DAO <span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span><p class="line867">
<h3 id="RPC_.26.26_REST">RPC &amp;&amp; REST</h3>
<span class="anchor" id="line-12"></span><p class="line874">* Rpc接口和REST接口的用途有什么区别？是否可以统一？ <span class="anchor" id="line-13"></span><span class="anchor" id="line-14"></span><p class="line874">REST ： GET 获取数据/POST 更新or创建数据/ DELETE 删除数据 RPC 直接用thrift 框架/非常容易实现，然后再写一个RPCHandler 即可 <span class="anchor" id="line-15"></span><span class="anchor" id="line-16"></span><p class="line874">* Spring注解中，@Bean和@Component有什么区别？ <span class="anchor" id="line-17"></span><span class="anchor" id="line-18"></span><ul><li style="list-style-type:none">@Component以及他的特殊化(@Controller, @Service 和 @Repository)允许在通过类路径扫描自动发现。@Bean却只能在配置类中明确的声明一个单例的bean。 <span class="anchor" id="line-19"></span><span class="anchor" id="line-20"></span></li></ul><p class="line874">*哪些地方使用了Spring AOP？没有 <span class="anchor" id="line-21"></span><span class="anchor" id="line-22"></span><p class="line867"><hr class="hr1" /><p class="line874"> <span class="anchor" id="line-23"></span>目前还没有QaQ <span class="anchor" id="line-24"></span><span class="anchor" id="line-25"></span><p class="line874">*数据存储除了mysql，还有什么可能的方案？Key--Value的nosql？ <span class="anchor" id="line-26"></span><span class="anchor" id="line-27"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-28"></span>
<h2 id="May_30">May 30</h2>
<span class="anchor" id="line-29"></span><p class="line867">
<h3 id="RestController">RestController</h3>
<span class="anchor" id="line-30"></span><p class="line862">1. 注意@<a class="nonexistent" href="/RestController">RestController</a> 和@Controller的区分 <span class="anchor" id="line-31"></span><span class="anchor" id="line-32"></span><p class="line867">
<h3 id="Mac_.2BUXOV7XrvU.2BM-">Mac 关闭端口</h3>
<span class="anchor" id="line-33"></span><p class="line874">2. MAC 查找并关闭8080 端口 查找8080端口 <span class="anchor" id="line-34"></span><span class="anchor" id="line-35"></span><p class="line874">sudo lsof -i :8080 <span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span><p class="line874">然后根据PID杀进程： <span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><p class="line874">sudo kill -9 61342（即pid） <span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><p class="line867">
<h3 id="A.2BZXBjbg-VO_.2BdoRPf3UoVzpmbw-">数据VO 的使用场景</h3>
<span class="anchor" id="line-42"></span><p class="line874">3. create 对象： logic 和controller 返回VO， service和db返回 id <span class="anchor" id="line-43"></span><span class="anchor" id="line-44"></span><p class="line867">
<h3 id="A.2BUXNOjg-Test">关于Test</h3>
<span class="anchor" id="line-45"></span><p class="line874">4. 测试尽量使用 assertthat <span class="anchor" id="line-46"></span><span class="anchor" id="line-47"></span><p class="line867">
<h3 id="Rest_.2BT391KInEgwM-">Rest 使用规范</h3>
<span class="anchor" id="line-48"></span><p class="line862">5. REST 规范：  <a class="http" href="http://wangwei.info/about-rest-api/">http://wangwei.info/about-rest-api/</a> <span class="anchor" id="line-49"></span><span class="anchor" id="line-50"></span><p class="line874">===== 单元测试 =====. <span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><ul><li style="list-style-type:none">@Spy <span class="anchor" id="line-53"></span><p class="line862">private <a class="nonexistent" href="/NamedParameterJdbcTemplate">NamedParameterJdbcTemplate</a> dbwriter = <a class="nonexistent" href="/TestDbHelper">TestDbHelper</a>.createNamedParameterJdbcTemplateInMemory(); @<a class="nonexistent" href="/InjectMocks">InjectMocks</a> private <a class="nonexistent" href="/DbTodoItemStorageImpl">DbTodoItemStorageImpl</a> todoItemStorage = new <a class="nonexistent" href="/DbTodoItemStorageImpl">DbTodoItemStorageImpl</a>(); <span class="anchor" id="line-54"></span><span class="anchor" id="line-55"></span></li></ul><p class="line874">注意sql名称和规范 <span class="anchor" id="line-56"></span><span class="anchor" id="line-57"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-58"></span>
<h2 id="May_31">May 31</h2>
<span class="anchor" id="line-59"></span><p class="line867">
<h3 id="DataNotFoundException">DataNotFoundException</h3>
<span class="anchor" id="line-60"></span><p class="line874">1. complete tutor-playground  RPC interface with thrift define. <span class="anchor" id="line-61"></span><span class="anchor" id="line-62"></span><p class="line862">when define the GET (by id) , need throw the <a class="nonexistent" href="/DataNotFound">DataNotFound</a> Exception every time! <span class="anchor" id="line-63"></span><span class="anchor" id="line-64"></span><p class="line867">
<h3 id="A.2BWJ5SoFtXa7U-Optional">增加字段Optional</h3>
<span class="anchor" id="line-65"></span><p class="line874">2. When add the new Attribute to the Object, in thrift , it should be optional! <span class="anchor" id="line-66"></span><span class="anchor" id="line-67"></span><p class="line867">
<h3 id="Mac_.2BU4ZT8lR9TuQ_.2BYwdO5A-">Mac 历史命令 指令</h3>
<span class="anchor" id="line-68"></span><p class="line862">3. tips :MAC查找历史命令～～～history |grep &lt;command&gt; <span class="anchor" id="line-69"></span><span class="anchor" id="line-70"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-71"></span>
<h2 id="June_4">June 4</h2>
<span class="anchor" id="line-72"></span><p class="line867">
<h3 id="Query_.2BdoROJHnNZblfDw-">Query 的两种方式</h3>
<span class="anchor" id="line-73"></span><p class="line874">spring sql query两种方式： 1. 用filter，在各个属性上建立filter（service层） 2. 使用条件condition判断，（db层） <span class="anchor" id="line-74"></span><span class="anchor" id="line-75"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-76"></span>
<h2 id="June_5">June 5</h2>
<span class="anchor" id="line-77"></span><p class="line867">
<h3 id="A.2BW4lRaIO3U9Y-userId.2Be0llcGNu-">安全获取userId等数据</h3>
<span class="anchor" id="line-78"></span><p class="line862">1. userId 需要从<a class="nonexistent" href="/SecHelper">SecHelper</a>中获取，防止他人伪造userId <span class="anchor" id="line-79"></span><span class="anchor" id="line-80"></span><p class="line867">
<h3 id="online.2BUgZlLw_.2BVAhedmTNT1w-">online分支 合并操作</h3>
<span class="anchor" id="line-81"></span><p class="line874">2. 合代码的git操作： <span class="anchor" id="line-82"></span><span class="anchor" id="line-83"></span><p class="line874">git checkout master <span class="anchor" id="line-84"></span><span class="anchor" id="line-85"></span><p class="line874">git pull <span class="anchor" id="line-86"></span><span class="anchor" id="line-87"></span><p class="line874">git checkout online <span class="anchor" id="line-88"></span><span class="anchor" id="line-89"></span><p class="line874">git pull <span class="anchor" id="line-90"></span><span class="anchor" id="line-91"></span><p class="line874">git merge origin/master --log --no-ff <span class="anchor" id="line-92"></span><span class="anchor" id="line-93"></span><p class="line874">git commit --amend <span class="anchor" id="line-94"></span><span class="anchor" id="line-95"></span><p class="line874">git push online-review <span class="anchor" id="line-96"></span><span class="anchor" id="line-97"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-98"></span>
<h3 id="DB_.2BZS9jAZicZYdbVw-">DB 支持颜文字</h3>
<span class="anchor" id="line-99"></span><p class="line874">3. Db支持U0001f60a颜文字等操作～～～： for example : tutorMentorApi.datasource.tomcat.initSQL: SET NAMES utf8mb4  (yaml) <span class="anchor" id="line-100"></span><span class="anchor" id="line-101"></span><p class="line862">CREATE TABLE <tt class="backtick">amaze_feedback</tt> ( <span class="anchor" id="line-102"></span><span class="anchor" id="line-103"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">userId</tt> int(11) unsigned NOT NULL, <span class="anchor" id="line-104"></span></li><li style="list-style-type:none"><p class="line891"><tt class="backtick">content</tt> text COLLATE utf8mb4_unicode_ci, <span class="anchor" id="line-105"></span></li><li style="list-style-type:none"><p class="line891"><tt class="backtick">imageIds</tt> text CHARACTER SET utf8 NOT NULL, <span class="anchor" id="line-106"></span></li><li style="list-style-type:none"><p class="line891"><tt class="backtick">createdTime</tt> bigint(20) NOT NULL, PRIMARY KEY (<tt class="backtick">id</tt>) <span class="anchor" id="line-107"></span><span class="anchor" id="line-108"></span></li></ul><p class="line874">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; <span class="anchor" id="line-109"></span><span class="anchor" id="line-110"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-111"></span>
<h3 id="A.2BmHl27pDof3JtQXoL-">项目部署流程</h3>
<span class="anchor" id="line-112"></span><p class="line862">4.项目部署基本流程: 参考wiki dev/deploy <a class="https" href="https://wiki.zhenguanyu.com/Dev/Deploy">https://wiki.zhenguanyu.com/Dev/Deploy</a> <span class="anchor" id="line-113"></span><span class="anchor" id="line-114"></span><p class="line874">观察上线状态，注意主机是否重启成功。stage机器上完后，登陆跳板机（ssh liht01@access1）, 以用户名tutor登陆到到相应的主机，查看／home／shared／log/下面的log文件，验证服务的状态。如果一切正常，点击"继续"来完成剩余机器的上线。 <span class="anchor" id="line-115"></span><span class="anchor" id="line-116"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-117"></span>
<h2 id="June_06">June 06</h2>
<span class="anchor" id="line-118"></span><p class="line867">
<h3 id="A.2BenpQPHaEUiRlrVSMj9RW3g-">空值的判断和返回</h3>
<span class="anchor" id="line-119"></span><p class="line874">1. 用前闭后开的区间来表示一个时间 Range <span class="anchor" id="line-120"></span><span class="anchor" id="line-121"></span><p class="line867">
<h3 id="A.2BenpQPFIkZa0-">空值判断</h3>
<span class="anchor" id="line-122"></span><p class="line862">2. String.isBlank(str); String.isNotBlank(str); <a class="nonexistent" href="/ArrayUtils">ArrayUtils</a>.isEmpty(arr); <a class="nonexistent" href="/ArrayUtils">ArrayUtils</a>.isNotEmpty(arr); <a class="nonexistent" href="/CollectionUtils">CollectionUtils</a>.isEmpty(coll); <span class="anchor" id="line-123"></span><span class="anchor" id="line-124"></span><p class="line867">
<h3 id="A.2Bj9RW3np6UDw-">返回空值</h3>
<span class="anchor" id="line-125"></span><p class="line862">3. Collections.emptyMap(); Collections.emptyList(); Collections.emptySet(); <a class="nonexistent" href="/StringUtils">StringUtils</a>.EMPTY; <span class="anchor" id="line-126"></span><span class="anchor" id="line-127"></span><p class="line862">-- JMS ：<a class="http" href="http://www.cnblogs.com/chenpi/p/5559349.html">http://www.cnblogs.com/chenpi/p/5559349.html</a> <span class="anchor" id="line-128"></span><span class="anchor" id="line-129"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-130"></span>
<h2 id="June_09">June 09</h2>
<span class="anchor" id="line-131"></span><p class="line867">
<h3 id="A.2BW.2FxR.2Bg-CSV">导出CSV</h3>
<span class="anchor" id="line-132"></span><p class="line874">Get skill : Java save data into CSV file <span class="anchor" id="line-133"></span><span class="anchor" id="line-134"></span><p class="line874">详见 tutor-address <span class="anchor" id="line-135"></span><span class="anchor" id="line-136"></span><p class="line874">注意，job 的日志一定要详细，有开始和结束！ <span class="anchor" id="line-137"></span><span class="anchor" id="line-138"></span><p class="line874">job结束后，最好有一个validare job <span class="anchor" id="line-139"></span><span class="anchor" id="line-140"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-141"></span>
<h2 id="June_10">June 10</h2>
<span class="anchor" id="line-142"></span><p class="line874">参加公司TB～ U0001f604 <span class="anchor" id="line-143"></span><span class="anchor" id="line-144"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-145"></span>
<h2 id="June_11">June 11</h2>
<span class="anchor" id="line-146"></span><p class="line867">
<h3 id="A.2BW.2FxlcFJnj8d6Cw-">导数剧过程</h3>
<span class="anchor" id="line-147"></span><p class="line874">完成导出用户地址job, <span class="anchor" id="line-148"></span><span class="anchor" id="line-149"></span><p class="line874">要连接跳板机， 上传自己的jar包及相关文件 到自己的工作目录下面。此处可用软连接：ln -s 源文件 目标文件 <span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span><p class="line862">关于上传文件： <a class="https" href="https://wiki.zhenguanyu.com/DEVOP/SEC/Mupload">https://wiki.zhenguanyu.com/DEVOP/SEC/Mupload</a> 随后使用wget 获取。 <span class="anchor" id="line-152"></span><span class="anchor" id="line-153"></span><p class="line874">运行jar包： <span class="anchor" id="line-154"></span><span class="anchor" id="line-155"></span><p class="line862">nohup java -jar xxxxxx.jar --server.port=9399 --spring.profiles.active=online --logging.config=classpath:log4j2.yaml --captain.enabled=false --job.active=XXXXXXXXXXXXXJob --fix=true &gt; log/XXXXXXXXXXX.out <span class="anchor" id="line-156"></span><span class="anchor" id="line-157"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-158"></span>继续tutor-playground2， 测试了res接口， 对第一次提交的代码进行修改， 研究了redis的用法及配置。 <span class="anchor" id="line-159"></span><span class="anchor" id="line-160"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-161"></span><span class="anchor" id="line-162"></span><p class="line867">
<h2 id="June_12">June 12</h2>
<span class="anchor" id="line-163"></span><p class="line874">上线了tutor-atm-lesson <span class="anchor" id="line-164"></span><span class="anchor" id="line-165"></span><p class="line874">更新数据时，LOG日志应该更详细一些， 第一次上传的job 没有 “job end ”信息， 差评！！！！！！！！！！！！！！ <span class="anchor" id="line-166"></span><span class="anchor" id="line-167"></span><p class="line874">继续tutor-playground， 使用缓存时还是要好好考虑数据一致性的问题哈！ <span class="anchor" id="line-168"></span><span class="anchor" id="line-169"></span><p class="line874">git 返回到最新的提交～git reset --hard origin/master <span class="anchor" id="line-170"></span><span class="anchor" id="line-171"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-172"></span><span class="anchor" id="line-173"></span><p class="line867">
<h2 id="June_13">June 13</h2>
<span class="anchor" id="line-174"></span><p class="line867">
<h3 id="git_.2BW2ZOYA-">git 学习</h3>
<span class="anchor" id="line-175"></span><p class="line874">git pull = git fetch + git merge <span class="anchor" id="line-176"></span><span class="anchor" id="line-177"></span><p class="line874">git pull --rebase = git fetch + git rebase <span class="anchor" id="line-178"></span><span class="anchor" id="line-179"></span><p class="line874">现在来看看git merge和git rebase的区别。 <span class="anchor" id="line-180"></span><span class="anchor" id="line-181"></span><p class="line874">假设有3次提交A,B,C。 <span class="anchor" id="line-182"></span><span class="anchor" id="line-183"></span><p class="line867"><img alt="imageView2/2/w/332" class="external_image" src="https://upload-images.jianshu.io/upload_images/310893-b3f2c56508fce814.png?imageMogr2/auto-orient/strip" title="imageView2/2/w/332" /> 在远程分支origin的基础上创建一个名为"mywork"的分支并提交了，同时有其他人在"origin"上做了一些修改并提交了。 <span class="anchor" id="line-184"></span><span class="anchor" id="line-185"></span><p class="line867"><img alt="imageView2/2/w/385" class="external_image" src="https://upload-images.jianshu.io/upload_images/310893-5e808595be2a25a0.png?imageMogr2/auto-orient/strip" title="imageView2/2/w/385" /> 其实这个时候E不应该提交，因为提交后会发生冲突。如何解决这些冲突呢？有以下两种方法： <span class="anchor" id="line-186"></span><span class="anchor" id="line-187"></span><p class="line867">
<h3 id="git_merge">git merge</h3>
<span class="anchor" id="line-188"></span><p class="line874">用git pull命令把"origin"分支上的修改pull下来与本地提交合并（merge）成版本M，但这样会形成图中的菱形，让人很困惑。 <span class="anchor" id="line-189"></span><span class="anchor" id="line-190"></span><p class="line867"><img alt="imageView2/2/w/448" class="external_image" src="https://upload-images.jianshu.io/upload_images/310893-d7b78643df684328.png?imageMogr2/auto-orient/strip" title="imageView2/2/w/448" /> <span class="anchor" id="line-191"></span><span class="anchor" id="line-192"></span><p class="line867">
<h3 id="git_rebase">git rebase</h3>
<span class="anchor" id="line-193"></span><p class="line874">创建一个新的提交R，R的文件内容和上面M的一样，但我们将E提交废除，当它不存在（图中用虚线表示）保持提交曲线为直线，让大家易于理解。 <span class="anchor" id="line-194"></span><span class="anchor" id="line-195"></span><p class="line874">在rebase的过程中，有时也会有conflict，这时Git会停止rebase并让用户去解决冲突，解决完冲突后，用git add命令去更新这些内容，然后不用执行git-commit,直接执行git rebase --continue,这样git会继续apply余下的补丁。在任何时候，都可以用git rebase --abort参数来终止rebase的行动，并且mywork分支会回到rebase开始前的状态。 <span class="anchor" id="line-196"></span><span class="anchor" id="line-197"></span><p class="line867"><img alt="imageView2/2/w/441" class="external_image" src="https://upload-images.jianshu.io/upload_images/310893-d1a838cd827f79ab.png?imageMogr2/auto-orient/strip" title="imageView2/2/w/441" /> <span class="anchor" id="line-198"></span><span class="anchor" id="line-199"></span><p class="line867">
<h3 id="git_reset">git reset</h3>
<span class="anchor" id="line-200"></span><p class="line862">git reset HEAD<sup>  回退版本，一个</sup>表示一个版本，可以多个，另外也可以使用 git reset HEAD～n这种形式。 <span class="anchor" id="line-201"></span><span class="anchor" id="line-202"></span><p class="line862">git reset --hard HEAD~1 更多命令  <a class="https" href="https://www.yiibai.com/git/git_reset.html">https://www.yiibai.com/git/git_reset.html</a>    hard 会删除上次提交之后的东西， soft不会？ <span class="anchor" id="line-203"></span><span class="anchor" id="line-204"></span><p class="line874">假设你已经添加了一个文件进入索引，但是而后又不打算把这个文件提交，此时可以使用git reset把这个文件从索引中去除 <span class="anchor" id="line-205"></span><span class="anchor" id="line-206"></span><p class="line874">$ git reset -- frotz.c                      (1) <span class="anchor" id="line-207"></span><span class="anchor" id="line-208"></span><p class="line874">$ git commit -m "Commit files in index"     (2) <span class="anchor" id="line-209"></span><span class="anchor" id="line-210"></span><p class="line874">$ git add frotz.c <span class="anchor" id="line-211"></span><span class="anchor" id="line-212"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-213"></span><span class="anchor" id="line-214"></span><p class="line867">
<h2 id="June_14">June 14</h2>
<span class="anchor" id="line-215"></span><p class="line874">今天主要做了 mentorAdvice 的相关操作工作 <span class="anchor" id="line-216"></span><span class="anchor" id="line-217"></span><p class="line867">
<h3 id="jsonCreater">jsonCreater</h3>
<span class="anchor" id="line-218"></span><p class="line862">@<a class="nonexistent" href="/JsonCreator">JsonCreator</a> 的包要注意！！！ <span class="anchor" id="line-219"></span><span class="anchor" id="line-220"></span><p class="line862">import com.fasterxml.jackson.annotation.<a class="nonexistent" href="/JsonCreator">JsonCreator</a>; <span class="anchor" id="line-221"></span><span class="anchor" id="line-222"></span><p class="line862">import com.fasterxml.jackson.annotation.<a class="nonexistent" href="/JsonValue">JsonValue</a>; <span class="anchor" id="line-223"></span><span class="anchor" id="line-224"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-225"></span><span class="anchor" id="line-226"></span><p class="line867">
<h2 id="June_16">June 16</h2>
<span class="anchor" id="line-227"></span><p class="line867">
<h3 id="A.2BfxNbWGVwY25ek04AgfRgJ5XumJg_callback.2BieNRsw-">缓存数据库一致性问题 callback解决</h3>
<span class="anchor" id="line-228"></span><p class="line874">主要看了redisson 和 db 操作，使用callback 解决数据不一致问题 <span class="anchor" id="line-229"></span><span class="anchor" id="line-230"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-231"></span><span class="anchor" id="line-232"></span><p class="line867">
<h2 id="June_19">June 19</h2>
<span class="anchor" id="line-233"></span><p class="line867">
<h3 id="Episode">Episode</h3>
<span class="anchor" id="line-234"></span><p class="line862">可参考： <a class="https" href="https://wiki.zhenguanyu.com/Livecast/MicroService/TutorEpisode#episode">https://wiki.zhenguanyu.com/Livecast/MicroService/TutorEpisode#episode</a> <span class="anchor" id="line-235"></span><span class="anchor" id="line-236"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-237"></span><span class="anchor" id="line-238"></span><p class="line867">
<h2 id="June_20">June 20</h2>
<span class="anchor" id="line-239"></span><p class="line874">熟悉了评价相关的业务。 <span class="anchor" id="line-240"></span><span class="anchor" id="line-241"></span><p class="line867">
<h3 id="Charles">Charles</h3>
<span class="anchor" id="line-242"></span><p class="line862">学会使用Charles 进行 mac 和 ios 端 请假捕获和抓包分析， 参考blog ： <a class="http" href="http://blog.devtang.com/2013/12/11/network-tool-charles-intr/">http://blog.devtang.com/2013/12/11/network-tool-charles-intr/</a> <span class="anchor" id="line-243"></span><span class="anchor" id="line-244"></span><p class="line874">遇到问题：需要Mac和iOS 安装相关证书，安装后，需要授权信任证书， 否则 网页或者app将无法打开。 <span class="anchor" id="line-245"></span><span class="anchor" id="line-246"></span><p class="line874">此外，网页端url 请求应该是统一处理过，无法查看， 但是app 端可以进行url查看 <span class="anchor" id="line-247"></span><span class="anchor" id="line-248"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-249"></span><span class="anchor" id="line-250"></span><p class="line867">
<h2 id="June_21">June 21</h2>
<span class="anchor" id="line-251"></span><p class="line867">
<h3 id="A.2BZyxXMHOvWINeOHUoU8JlcJFNf24-">本地环境常用参数配置</h3>
<span class="anchor" id="line-252"></span><p class="line874">--spring.profiles=test <span class="anchor" id="line-253"></span><span class="anchor" id="line-254"></span><p class="line874">--logging.config=classpath:log4j2.yaml <span class="anchor" id="line-255"></span><span class="anchor" id="line-256"></span><p class="line874">--rpcServer.port=5110 <span class="anchor" id="line-257"></span><span class="anchor" id="line-258"></span><p class="line874">--captain.restfulPort=6110 <span class="anchor" id="line-259"></span><span class="anchor" id="line-260"></span><p class="line874">--actuator.enabled=false <span class="anchor" id="line-261"></span><span class="anchor" id="line-262"></span><p class="line874">--logging.access.directory=/Users/chenkuan/Desktop/Yuanfudao <span class="anchor" id="line-263"></span><span class="anchor" id="line-264"></span><p class="line867">
<h3 id="Git_Cherry_Pick_.2BZM1PXA-">Git Cherry Pick 操作</h3>
<span class="anchor" id="line-265"></span><p class="line874">Master： <span class="anchor" id="line-266"></span><span class="anchor" id="line-267"></span><p class="line874">git ll 找到commit 记下 <span class="anchor" id="line-268"></span><span class="anchor" id="line-269"></span><p class="line874">git checkout online <span class="anchor" id="line-270"></span><span class="anchor" id="line-271"></span><p class="line874">git pull git cherry-pick a7099c3 <span class="anchor" id="line-272"></span><span class="anchor" id="line-273"></span><p class="line874">git commit --amend <span class="anchor" id="line-274"></span><span class="anchor" id="line-275"></span><p class="line867">
<h3 id="A.2BUiR6eg_.2BVIw_.2BUgZrtYv7U9Y-">判空 和 分段读取</h3>
<span class="anchor" id="line-276"></span><p class="line874">习惯性的对集合判空 <span class="anchor" id="line-277"></span><span class="anchor" id="line-278"></span><p class="line874">--- <span class="anchor" id="line-279"></span><span class="anchor" id="line-280"></span><p class="line862">@<a class="nonexistent" href="/ActuatorAnalysis">ActuatorAnalysis</a> <span class="anchor" id="line-281"></span><span class="anchor" id="line-282"></span><p class="line874">使用RPC时尽量分段读取 <span class="anchor" id="line-283"></span><span class="anchor" id="line-284"></span><p class="line862">Tip <a class="nonexistent" href="/MapUtilsEx">MapUtilsEx</a>.convertValue <span class="anchor" id="line-285"></span><span class="anchor" id="line-286"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-287"></span><span class="anchor" id="line-288"></span><p class="line867">
<h2 id="June_22">June 22</h2>
<span class="anchor" id="line-289"></span><p class="line874">今天写业务 <span class="anchor" id="line-290"></span><span class="anchor" id="line-291"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-292"></span><span class="anchor" id="line-293"></span><p class="line867">
<h2 id="June_25">June 25</h2>
<span class="anchor" id="line-294"></span><p class="line874">业务 <span class="anchor" id="line-295"></span><span class="anchor" id="line-296"></span><p class="line867">
<h2 id="June_26">June 26</h2>
<span class="anchor" id="line-297"></span><p class="line874">导出数据时，尽量分段导出。 <span class="anchor" id="line-298"></span><span class="anchor" id="line-299"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-300"></span><span class="anchor" id="line-301"></span><p class="line867">
<h2 id="June_27">June 27</h2>
<span class="anchor" id="line-302"></span><p class="line867">
<h3 id="A.2BW2ZOYG4FdAZnDVKh-">学习清理服务</h3>
<span class="anchor" id="line-303"></span><p class="line862">学习了如何了进行服务清理： 检查服务依赖，查看日志文件&gt;&gt;&gt;&gt;删除代码&gt;&gt;&gt;&gt;修改nginx&gt;&gt;&gt;&gt;删除服务实例 参考连接： <a class="https" href="https://wiki.zhenguanyu.com/Livecast/B/ServiceClean">https://wiki.zhenguanyu.com/Livecast/B/ServiceClean</a> <span class="anchor" id="line-304"></span><span class="anchor" id="line-305"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-306"></span><span class="anchor" id="line-307"></span><p class="line867">
<h2 id="June_28_.26_29">June 28 &amp; 29</h2>
<span class="anchor" id="line-308"></span><p class="line874">进行服务清理，好像没遇到坑 <span class="anchor" id="line-309"></span>
<h3 id="A.2BfSJfFQ_ES">索引 ES</h3>
<span class="anchor" id="line-310"></span><p class="line867"><a class="http" href="http://www.baeldung.com/lucene">http://www.baeldung.com/lucene</a>   <span class="anchor" id="line-311"></span><span class="anchor" id="line-312"></span><p class="line867"><a class="https" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html</a>  <span class="anchor" id="line-313"></span><span class="anchor" id="line-314"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-315"></span><span class="anchor" id="line-316"></span><p class="line867">
<h2 id="July_2">July 2</h2>
<span class="anchor" id="line-317"></span><p class="line867">
<h3 id="cache_key">cache key</h3>
<span class="anchor" id="line-318"></span><p class="line874">使用的时候注意，不要忘记id !!!!!!!!! 今天是一个惨痛的教训 <span class="anchor" id="line-319"></span><span class="anchor" id="line-320"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-321"></span><span class="anchor" id="line-322"></span><p class="line867">
<h2 id="July_3">July 3</h2>
<span class="anchor" id="line-323"></span><p class="line874">service 上线时候记得刷新， <span class="anchor" id="line-324"></span><span class="anchor" id="line-325"></span><p class="line862">另外又学会了 git revert---&gt;git commit --amend ---&gt;git push <span class="anchor" id="line-326"></span><span class="anchor" id="line-327"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-328"></span><span class="anchor" id="line-329"></span><p class="line867">
<h2 id="July_4">July 4</h2>
<span class="anchor" id="line-330"></span><p class="line862">Tips： 自动引入Jar包时也要看看版本，某些低版本功能可能不完善，比如 <a class="nonexistent" href="/StringUtils">StringUtils</a>.isNumberic 不同版本就有不一样的处理 <span class="anchor" id="line-331"></span><span class="anchor" id="line-332"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-333"></span><span class="anchor" id="line-334"></span><p class="line867">
<h2 id="July_5">July 5</h2>
<span class="anchor" id="line-335"></span><p class="line874">今天第一次发布Maven 包 <span class="anchor" id="line-336"></span><span class="anchor" id="line-337"></span><p class="line874">maven clean deploy <span class="anchor" id="line-338"></span><span class="anchor" id="line-339"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-340"></span><span class="anchor" id="line-341"></span><p class="line867">
<h2 id="July_6">July 6</h2>
<span class="anchor" id="line-342"></span><p class="line862">今日有红牛，<a class="nonexistent" href="/JavaCpp">JavaCpp</a> 有点难。。。 <span class="anchor" id="line-343"></span><span class="anchor" id="line-344"></span><p class="line874">1. 预习新牛课程 <span class="anchor" id="line-345"></span><span class="anchor" id="line-346"></span><p class="line862">[Pro Git](<a class="https" href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a>) 前3章，尤其是第3章*分支* <span class="anchor" id="line-347"></span><span class="anchor" id="line-348"></span><p class="line867">
<h2 id="July_9_.26.26_July_10">July 9 &amp;&amp; July 10</h2>
<span class="anchor" id="line-349"></span><p class="line874">复习Git， 上线业务 <span class="anchor" id="line-350"></span><span class="anchor" id="line-351"></span><p class="line874">学习了 Maven 和 shell <span class="anchor" id="line-352"></span><span class="anchor" id="line-353"></span><p class="line867"><a class="https" href="https://www.jianshu.com/p/e1c8e5bfa45e">https://www.jianshu.com/p/e1c8e5bfa45e</a> <span class="anchor" id="line-354"></span><span class="anchor" id="line-355"></span><p class="line867"><a class="http" href="http://www.infoq.com/cn/minibooks/maven-in-action">http://www.infoq.com/cn/minibooks/maven-in-action</a> <span class="anchor" id="line-356"></span><span class="anchor" id="line-357"></span><p class="line874">对Maven 有了进一步的了解，以前只会用但没有详细了解过。 对shell也有了大致的了解，可以看懂代码了，有机会自己写个东西玩玩 <span class="anchor" id="line-358"></span><span class="anchor" id="line-359"></span><p class="line867">
<h2 id="July_11">July 11</h2>
<span class="anchor" id="line-360"></span><p class="line874">上午scrum 会， 下午完成了两个task， 顺便读了读 Java 8 实战 <span class="anchor" id="line-361"></span><span class="anchor" id="line-362"></span><p class="line867">
<h2 id="July_12">July 12</h2>
<span class="anchor" id="line-363"></span><p class="line867">
<h3 id="git_reset_.2BTgl5zQ-">git reset 三种</h3>
<span class="anchor" id="line-364"></span><p class="line867"><a class="https" href="https://www.cnblogs.com/kidsitcn/p/4513297.html">https://www.cnblogs.com/kidsitcn/p/4513297.html</a> <span class="anchor" id="line-365"></span><span class="anchor" id="line-366"></span><p class="line867">
<h3 id="A.2BZbByW1tmTmA---Git.2B.2Fww-MVN.2B.2Fww-shell">新牛学习--Git，MVN，shell</h3>
<span class="anchor" id="line-367"></span><p class="line867"><span class="anchor" id="line-368"></span><span class="anchor" id="line-369"></span><span class="anchor" id="line-370"></span><span class="anchor" id="line-371"></span><span class="anchor" id="line-372"></span><span class="anchor" id="line-373"></span><span class="anchor" id="line-374"></span><span class="anchor" id="line-375"></span><span class="anchor" id="line-376"></span><span class="anchor" id="line-377"></span><span class="anchor" id="line-378"></span><span class="anchor" id="line-379"></span><span class="anchor" id="line-380"></span><span class="anchor" id="line-381"></span><span class="anchor" id="line-382"></span><span class="anchor" id="line-383"></span><span class="anchor" id="line-384"></span><span class="anchor" id="line-385"></span><span class="anchor" id="line-386"></span><span class="anchor" id="line-387"></span><span class="anchor" id="line-388"></span><span class="anchor" id="line-389"></span><span class="anchor" id="line-390"></span><span class="anchor" id="line-391"></span><span class="anchor" id="line-392"></span><span class="anchor" id="line-393"></span><span class="anchor" id="line-394"></span><span class="anchor" id="line-395"></span><span class="anchor" id="line-396"></span><span class="anchor" id="line-397"></span><span class="anchor" id="line-398"></span><span class="anchor" id="line-399"></span><span class="anchor" id="line-400"></span><span class="anchor" id="line-401"></span><span class="anchor" id="line-402"></span><span class="anchor" id="line-403"></span><span class="anchor" id="line-404"></span><span class="anchor" id="line-405"></span><span class="anchor" id="line-406"></span><span class="anchor" id="line-407"></span><span class="anchor" id="line-408"></span><span class="anchor" id="line-409"></span><span class="anchor" id="line-410"></span><span class="anchor" id="line-411"></span><span class="anchor" id="line-412"></span><span class="anchor" id="line-413"></span><span class="anchor" id="line-414"></span><span class="anchor" id="line-415"></span><span class="anchor" id="line-416"></span><span class="anchor" id="line-417"></span><span class="anchor" id="line-418"></span><span class="anchor" id="line-419"></span><span class="anchor" id="line-420"></span><span class="anchor" id="line-421"></span><span class="anchor" id="line-422"></span><span class="anchor" id="line-423"></span><span class="anchor" id="line-424"></span><span class="anchor" id="line-425"></span><span class="anchor" id="line-426"></span><span class="anchor" id="line-427"></span><span class="anchor" id="line-428"></span><span class="anchor" id="line-429"></span><span class="anchor" id="line-430"></span><span class="anchor" id="line-431"></span><span class="anchor" id="line-432"></span><span class="anchor" id="line-433"></span><span class="anchor" id="line-434"></span><span class="anchor" id="line-435"></span><span class="anchor" id="line-436"></span><span class="anchor" id="line-437"></span><span class="anchor" id="line-438"></span><span class="anchor" id="line-439"></span><span class="anchor" id="line-440"></span><span class="anchor" id="line-441"></span><span class="anchor" id="line-442"></span><span class="anchor" id="line-443"></span><span class="anchor" id="line-444"></span><span class="anchor" id="line-445"></span><span class="anchor" id="line-446"></span><span class="anchor" id="line-447"></span><span class="anchor" id="line-448"></span><span class="anchor" id="line-449"></span><span class="anchor" id="line-450"></span><pre><span class="anchor" id="line-1"></span>* Git如何存储数据
<span class="anchor" id="line-2"></span>    * Snapshot vs Diff
<span class="anchor" id="line-3"></span>    
<span class="anchor" id="line-4"></span>    Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。
<span class="anchor" id="line-5"></span>    Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。
<span class="anchor" id="line-6"></span>    
<span class="anchor" id="line-7"></span>    * 如何存储目录？
<span class="anchor" id="line-8"></span>    * 如何保证数据完整性
<span class="anchor" id="line-9"></span>        
<span class="anchor" id="line-10"></span>     Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。
<span class="anchor" id="line-11"></span>     Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：
<span class="anchor" id="line-12"></span>     24b9da6552252987aa493b52f8696cd6d3b00373
<span class="anchor" id="line-13"></span>     Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。
<span class="anchor" id="line-14"></span>
<span class="anchor" id="line-15"></span>* 文件状态
<span class="anchor" id="line-16"></span>    * 三个区域
<span class="anchor" id="line-17"></span>        * 工作区 working directory
<span class="anchor" id="line-18"></span>        * 暂存区 staging area
<span class="anchor" id="line-19"></span>        * 仓库  repo
<span class="anchor" id="line-20"></span>    * git reset的不同类型
<span class="anchor" id="line-21"></span>    git 的三种状态 和 reset感觉灰常有意思，棒！ 主要是Hard（三个指针都移动）， Soft（暂存区和仓库移动） 和Mixed（仓库移动）
<span class="anchor" id="line-22"></span>---
<span class="anchor" id="line-23"></span>
<span class="anchor" id="line-24"></span>### Git Workflow
<span class="anchor" id="line-25"></span>* branch和commit的关系
<span class="anchor" id="line-26"></span>* 在gerrit上提交一个review，工作流程是怎么样的
<span class="anchor" id="line-27"></span>    * 如果把分支A提到了分支B，会发生什么
<span class="anchor" id="line-28"></span>* rebase和merge的机制和适用场景
<span class="anchor" id="line-29"></span>* github的工作流程*
<span class="anchor" id="line-30"></span>* 版本管理工具的变迁*
<span class="anchor" id="line-31"></span>
<span class="anchor" id="line-32"></span>---
<span class="anchor" id="line-33"></span>
<span class="anchor" id="line-34"></span>### Maven
<span class="anchor" id="line-35"></span>* [幻灯片](https://wiki.zhenguanyu.com/fankai?action=AttachFile&amp;do=view&amp;target=Maven%E7%AE%80%E4%BB%8B.pdf)
<span class="anchor" id="line-36"></span>* 作为项目的对象模型
<span class="anchor" id="line-37"></span>    * 坐标与版本
<span class="anchor" id="line-38"></span>    * SNAPSHOT版本的意义
<span class="anchor" id="line-39"></span>* Maven的生命周期(clean default site (default 为主))
<span class="anchor" id="line-40"></span>    * 每个生命周期是一组有序的阶段 validate-&gt;compile-&gt;test-&gt;package-&gt;verify-&gt;install-&gt;deploy
<span class="anchor" id="line-41"></span>    * 解释mvn clean package的意义
<span class="anchor" id="line-42"></span>* Maven依赖管理
<span class="anchor" id="line-43"></span>   * 仓库的概念   (中央仓库，公司仓库)
<span class="anchor" id="line-44"></span>    
<span class="anchor" id="line-45"></span>   * 依赖范围  
<span class="anchor" id="line-46"></span>    compile 默认，编译，测试，运行都需要
<span class="anchor" id="line-47"></span>    provided 只在编译和测试时需要
<span class="anchor" id="line-48"></span>    runtime 只在测试和运行的时候需要
<span class="anchor" id="line-49"></span>    test 只在测试时候需要
<span class="anchor" id="line-50"></span>
<span class="anchor" id="line-51"></span>    * 如何确定依赖的版本
<span class="anchor" id="line-52"></span>    1. 显示确定依赖版本 2 DependencyManageMent中定义的版本 3. 传递依赖路径中长度最短的版本 
<span class="anchor" id="line-53"></span>* Maven常用命令
<span class="anchor" id="line-54"></span>mvn dependency:list
<span class="anchor" id="line-55"></span>mvn dependency:tree
<span class="anchor" id="line-56"></span>mvn dependency:analyze
<span class="anchor" id="line-57"></span>---
<span class="anchor" id="line-58"></span>
<span class="anchor" id="line-59"></span>### Shell脚本
<span class="anchor" id="line-60"></span>* Shell基础
<span class="anchor" id="line-61"></span>    * 变量
<span class="anchor" id="line-62"></span>    * 运算符
<span class="anchor" id="line-63"></span>    * 控制流
<span class="anchor" id="line-64"></span>* Shell脚本的适用场景
<span class="anchor" id="line-65"></span>* Shell脚本如何实现后台运行、重定向、并发等功能
<span class="anchor" id="line-66"></span>* 常用文本处理工具
<span class="anchor" id="line-67"></span>
<span class="anchor" id="line-68"></span>---
<span class="anchor" id="line-69"></span>
<span class="anchor" id="line-70"></span>### UNIX 设计原则
<span class="anchor" id="line-71"></span>* Controlling complexity is the essence of computer programming.
<span class="anchor" id="line-72"></span>* Keep It Simple, Stupid!
<span class="anchor" id="line-73"></span>
<span class="anchor" id="line-74"></span>---
<span class="anchor" id="line-75"></span>
<span class="anchor" id="line-76"></span>### 代码规范
<span class="anchor" id="line-77"></span>* 代码规范的原则和意义
<span class="anchor" id="line-78"></span>    * Programs must be written for people to read, and only incidentally for machines to execute. - SICP
<span class="anchor" id="line-79"></span>    * 保持代码风格的一致性比起追求最好的风格更加重要
<span class="anchor" id="line-80"></span>    * 重构是保持代码质量的重要手段
<span class="anchor" id="line-81"></span>
<span class="anchor" id="line-82"></span>---</pre><span class="anchor" id="line-451"></span><span class="anchor" id="line-452"></span><span class="anchor" id="line-453"></span><p class="line867">
<h2 id="July_13">July 13</h2>
<span class="anchor" id="line-454"></span><p class="line874">tutor-team服务整理 <span class="anchor" id="line-455"></span><span class="anchor" id="line-456"></span><p class="line867">
<h2 id="July_14">July 14</h2>
<span class="anchor" id="line-457"></span><p class="line874">周末来公司看了下 java 8 实战， 1-4 章。 <span class="anchor" id="line-458"></span><span class="anchor" id="line-459"></span><p class="line862">行为参数化(传递代码)-&gt;匿名类-&gt;Lambda表达式-&gt;使用方法引用 <span class="anchor" id="line-460"></span><span class="anchor" id="line-461"></span><p class="line874">引入流的概念，stream 内部有些像流水线式工作 <span class="anchor" id="line-462"></span><span class="anchor" id="line-463"></span><p class="line867">
<h2 id="July_15">July 15</h2>
<span class="anchor" id="line-464"></span><p class="line867">
<h3 id="A.2BZbByWw---Java">新牛--Java</h3>
<span class="anchor" id="line-465"></span><span class="anchor" id="line-466"></span><p class="line867"><span class="anchor" id="line-467"></span><span class="anchor" id="line-468"></span><span class="anchor" id="line-469"></span><span class="anchor" id="line-470"></span><span class="anchor" id="line-471"></span><span class="anchor" id="line-472"></span><span class="anchor" id="line-473"></span><span class="anchor" id="line-474"></span><span class="anchor" id="line-475"></span><span class="anchor" id="line-476"></span><pre><span class="anchor" id="line-1-1"></span>## 学习目标
<span class="anchor" id="line-2-1"></span>* 掌握Java语言的常用特性，包括
<span class="anchor" id="line-3-1"></span>    * 异常处理机制
<span class="anchor" id="line-4-1"></span>    * 类型信息和反射机制
<span class="anchor" id="line-5-1"></span>    * 泛型的原理和使用
<span class="anchor" id="line-6-1"></span>    * 注解
<span class="anchor" id="line-7-1"></span>* 了解Java 8引入的新特性
<span class="anchor" id="line-8-1"></span>    * Lambda表达式
<span class="anchor" id="line-9-1"></span>    * Stream API</pre><span class="anchor" id="line-477"></span><span class="anchor" id="line-478"></span><p class="line867"><span class="anchor" id="line-479"></span><span class="anchor" id="line-480"></span><span class="anchor" id="line-481"></span><span class="anchor" id="line-482"></span><span class="anchor" id="line-483"></span><span class="anchor" id="line-484"></span><span class="anchor" id="line-485"></span><span class="anchor" id="line-486"></span><span class="anchor" id="line-487"></span><span class="anchor" id="line-488"></span><span class="anchor" id="line-489"></span><span class="anchor" id="line-490"></span><span class="anchor" id="line-491"></span><span class="anchor" id="line-492"></span><span class="anchor" id="line-493"></span><pre><span class="anchor" id="line-1-2"></span>## 异常
<span class="anchor" id="line-2-2"></span>* 异常 vs 错误码
<span class="anchor" id="line-3-2"></span>* Java异常的分类和层次
<span class="anchor" id="line-4-2"></span>* Checked Exception vs Unchecked Exception
<span class="anchor" id="line-5-2"></span>    * 各自有什么优缺点
<span class="anchor" id="line-6-2"></span>* 如何保证释放资源
<span class="anchor" id="line-7-2"></span>    * 如果在catch或者finally块里抛出异常会如何？
<span class="anchor" id="line-8-2"></span>    上一个异常会被吞掉
<span class="anchor" id="line-9-2"></span>    * 如果在构造函数中跑出异常会如何？
<span class="anchor" id="line-10-1"></span>    不要这么做，会=有可能会使程序无法执行，也会增加上层编程人员的开发难度
<span class="anchor" id="line-11-1"></span>    * try-with-resource *
<span class="anchor" id="line-12-1"></span>    会释放资源
<span class="anchor" id="line-13-1"></span>* 什么叫suppressed exception，如果保留
<span class="anchor" id="line-14-1"></span>* 永远不要吞异常！</pre><span class="anchor" id="line-494"></span><span class="anchor" id="line-495"></span><p class="line867"><span class="anchor" id="line-496"></span><span class="anchor" id="line-497"></span><span class="anchor" id="line-498"></span><span class="anchor" id="line-499"></span><span class="anchor" id="line-500"></span><span class="anchor" id="line-501"></span><span class="anchor" id="line-502"></span><span class="anchor" id="line-503"></span><span class="anchor" id="line-504"></span><span class="anchor" id="line-505"></span><span class="anchor" id="line-506"></span><span class="anchor" id="line-507"></span><span class="anchor" id="line-508"></span><pre><span class="anchor" id="line-1-3"></span>### 类型信息RTTI
<span class="anchor" id="line-2-3"></span>* 类型也是一个对象
<span class="anchor" id="line-3-3"></span>* 获取和使用获取类型信息
<span class="anchor" id="line-4-3"></span>    * 向下转型 downcast
<span class="anchor" id="line-5-3"></span>    * instanceof 操作符
<span class="anchor" id="line-6-3"></span>    * isInstance() 方法
<span class="anchor" id="line-7-3"></span>    * typeid and typeinfo in c++ *
<span class="anchor" id="line-8-3"></span>* 反射
<span class="anchor" id="line-9-3"></span>* 动态代理
<span class="anchor" id="line-10-2"></span>    * 什么是代理模式
<span class="anchor" id="line-11-2"></span>    * 动态代理的作用
<span class="anchor" id="line-12-2"></span>    AOP用到</pre><span class="anchor" id="line-509"></span><span class="anchor" id="line-510"></span><p class="line867"><span class="anchor" id="line-511"></span><span class="anchor" id="line-512"></span><span class="anchor" id="line-513"></span><span class="anchor" id="line-514"></span><span class="anchor" id="line-515"></span><span class="anchor" id="line-516"></span><span class="anchor" id="line-517"></span><span class="anchor" id="line-518"></span><span class="anchor" id="line-519"></span><span class="anchor" id="line-520"></span><span class="anchor" id="line-521"></span><span class="anchor" id="line-522"></span><span class="anchor" id="line-523"></span><span class="anchor" id="line-524"></span><span class="anchor" id="line-525"></span><span class="anchor" id="line-526"></span><span class="anchor" id="line-527"></span><span class="anchor" id="line-528"></span><span class="anchor" id="line-529"></span><span class="anchor" id="line-530"></span><span class="anchor" id="line-531"></span><span class="anchor" id="line-532"></span><span class="anchor" id="line-533"></span><span class="anchor" id="line-534"></span><pre><span class="anchor" id="line-1-4"></span>### 泛型
<span class="anchor" id="line-2-4"></span>* 泛型和继承
<span class="anchor" id="line-3-4"></span>    * 协变 covariance
<span class="anchor" id="line-4-4"></span>    * 逆变 contravariance
<span class="anchor" id="line-5-4"></span>    * 不变 invariance
<span class="anchor" id="line-6-4"></span>~~~
<span class="anchor" id="line-7-4"></span>if a Derived is a Base, then
<span class="anchor" id="line-8-4"></span>   a Collection&lt;Derived&gt; is a Collection&lt;Base&gt; ?
<span class="anchor" id="line-9-4"></span>or a Collection&lt;Base&gt; is a Collection&lt;Derived&gt; ?
<span class="anchor" id="line-10-3"></span>~~~
<span class="anchor" id="line-11-3"></span>
<span class="anchor" id="line-12-3"></span>* 泛型数组？
<span class="anchor" id="line-13-2"></span>集合是不变的，数组是协变的
<span class="anchor" id="line-14-2"></span>---
<span class="anchor" id="line-15-1"></span>
<span class="anchor" id="line-16-1"></span>### 泛型
<span class="anchor" id="line-17-1"></span>* 泛型和继承
<span class="anchor" id="line-18-1"></span>~~~
<span class="anchor" id="line-19-1"></span>List&lt;Object&gt; objs = new ArrayList&lt;Integer&gt;();
<span class="anchor" id="line-20-1"></span>objs.add(3);
<span class="anchor" id="line-21-1"></span>objs.add("hello");
<span class="anchor" id="line-22-1"></span>~~~</pre><span class="anchor" id="line-535"></span><p class="line867"><span class="anchor" id="line-536"></span><span class="anchor" id="line-537"></span><span class="anchor" id="line-538"></span><span class="anchor" id="line-539"></span><pre><span class="anchor" id="line-1-5"></span>### 注解
<span class="anchor" id="line-2-5"></span>* 注解如何发挥作用
<span class="anchor" id="line-3-5"></span>* 各个元注解的意义 *</pre><span class="anchor" id="line-540"></span><span class="anchor" id="line-541"></span><p class="line867"><span class="anchor" id="line-542"></span><span class="anchor" id="line-543"></span><span class="anchor" id="line-544"></span><span class="anchor" id="line-545"></span><span class="anchor" id="line-546"></span><span class="anchor" id="line-547"></span><span class="anchor" id="line-548"></span><span class="anchor" id="line-549"></span><pre><span class="anchor" id="line-1-6"></span>### Lambda表达式
<span class="anchor" id="line-2-6"></span>* 从匿名类到Lambda表达式
<span class="anchor" id="line-3-6"></span>    * 闭包
<span class="anchor" id="line-4-5"></span>    * 有什么区别？
<span class="anchor" id="line-5-5"></span>* 函数式接口
<span class="anchor" id="line-6-5"></span>    * 函数不是一等公民(first class)
<span class="anchor" id="line-7-5"></span>    * 常用接口</pre><span class="anchor" id="line-550"></span><p class="line867"><span class="anchor" id="line-551"></span><span class="anchor" id="line-552"></span><span class="anchor" id="line-553"></span><span class="anchor" id="line-554"></span><span class="anchor" id="line-555"></span><span class="anchor" id="line-556"></span><span class="anchor" id="line-557"></span><span class="anchor" id="line-558"></span><span class="anchor" id="line-559"></span><pre><span class="anchor" id="line-1-7"></span>### Stream基本操作#
<span class="anchor" id="line-2-7"></span>* 不修改数据源
<span class="anchor" id="line-3-7"></span>* 延迟操作 (lazy execution)
<span class="anchor" id="line-4-6"></span>* 副作用 (side effect)
<span class="anchor" id="line-5-6"></span>* 常用操作
<span class="anchor" id="line-6-6"></span>
<span class="anchor" id="line-7-6"></span>* Optional如何解决NPE
<span class="anchor" id="line-8-5"></span>* Optional链式操作</pre><span class="anchor" id="line-560"></span><span class="anchor" id="line-561"></span><p class="line867">
<h2 id="July_17">July 17</h2>
<span class="anchor" id="line-562"></span><p class="line867">
<h3 id="git_.2BT.2B5lOU5LUk1j0E6kj8d2hFGFW7k-">git 修改之前提交过的内容</h3>
<span class="anchor" id="line-563"></span><p class="line867"><span class="anchor" id="line-564"></span><span class="anchor" id="line-565"></span><span class="anchor" id="line-566"></span><span class="anchor" id="line-567"></span><span class="anchor" id="line-568"></span><span class="anchor" id="line-569"></span><span class="anchor" id="line-570"></span><span class="anchor" id="line-571"></span><span class="anchor" id="line-572"></span><pre><span class="anchor" id="line-1-8"></span>git log –oneline 查看head
<span class="anchor" id="line-2-8"></span>git rebase -i xxxxxxx回到想修改的提交之前
<span class="anchor" id="line-3-8"></span>选择进行edit  
<span class="anchor" id="line-4-7"></span>进行修改
<span class="anchor" id="line-5-7"></span>git add . 
<span class="anchor" id="line-6-7"></span>git commit –amend (依然使用原来的提交) 
<span class="anchor" id="line-7-7"></span>git rebase –continue
<span class="anchor" id="line-8-6"></span>结束</pre><span class="anchor" id="line-573"></span><span class="anchor" id="line-574"></span><p class="line867">
<h3 id="shell">shell</h3>
<span class="anchor" id="line-575"></span><p class="line867"><span class="anchor" id="line-576"></span><span class="anchor" id="line-577"></span><span class="anchor" id="line-578"></span><pre><span class="anchor" id="line-1-9"></span>grep 'duration=[0-9][0-9]' http-request.log | cut -f4 |sort |uniq -c|sort -nr &gt;result
<span class="anchor" id="line-2-9"></span>grep 'products/342' http-request.log | cut -f1 -d :|uniq -c  &gt;result1</pre><span class="anchor" id="line-579"></span><p class="line874">作业里学到的两个shell 命令 <span class="anchor" id="line-580"></span><span class="anchor" id="line-581"></span><p class="line867">
<h2 id="July_18">July 18</h2>
<span class="anchor" id="line-582"></span><p class="line867">
<h3 id="Test_.2BXA9XUQ-">Test 小坑</h3>
<span class="anchor" id="line-583"></span><p class="line874">注意不可以 Test method为private <span class="anchor" id="line-584"></span><span class="anchor" id="line-585"></span><p class="line867">
<h2 id="July_19">July 19</h2>
<span class="anchor" id="line-586"></span><p class="line867">
<h3 id="A.2BZbByW1tmTmA---JVM_.2BbfFRZU6GieM-">新牛学习--JVM 深入了解</h3>
<span class="anchor" id="line-587"></span><p class="line867"><span class="anchor" id="line-588"></span><span class="anchor" id="line-589"></span><span class="anchor" id="line-590"></span><span class="anchor" id="line-591"></span><span class="anchor" id="line-592"></span><span class="anchor" id="line-593"></span><pre><span class="anchor" id="line-1-10"></span>### JVM
<span class="anchor" id="line-2-10"></span>* VM的概念和作用
<span class="anchor" id="line-3-9"></span>* JVM vs Java
<span class="anchor" id="line-4-8"></span>* 其他VM
<span class="anchor" id="line-5-8"></span>---</pre><span class="anchor" id="line-594"></span><span class="anchor" id="line-595"></span><p class="line867"><span class="anchor" id="line-596"></span><span class="anchor" id="line-597"></span><span class="anchor" id="line-598"></span><span class="anchor" id="line-599"></span><span class="anchor" id="line-600"></span><span class="anchor" id="line-601"></span><span class="anchor" id="line-602"></span><span class="anchor" id="line-603"></span><span class="anchor" id="line-604"></span><span class="anchor" id="line-605"></span><span class="anchor" id="line-606"></span><span class="anchor" id="line-607"></span><span class="anchor" id="line-608"></span><span class="anchor" id="line-609"></span><span class="anchor" id="line-610"></span><span class="anchor" id="line-611"></span><span class="anchor" id="line-612"></span><span class="anchor" id="line-613"></span><span class="anchor" id="line-614"></span><span class="anchor" id="line-615"></span><span class="anchor" id="line-616"></span><span class="anchor" id="line-617"></span><span class="anchor" id="line-618"></span><span class="anchor" id="line-619"></span><span class="anchor" id="line-620"></span><span class="anchor" id="line-621"></span><span class="anchor" id="line-622"></span><span class="anchor" id="line-623"></span><span class="anchor" id="line-624"></span><span class="anchor" id="line-625"></span><span class="anchor" id="line-626"></span><pre><span class="anchor" id="line-1-11"></span>### 内存数据区域
<span class="anchor" id="line-2-11"></span>* 有哪些数据区域
<span class="anchor" id="line-3-10"></span>1. 程序计数器，在虚拟机概念模型里，字节码解释器工作时候就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支循环，跳转，异常处理，线程恢复等基础功能，都需要依赖这个计数器完成。 为了线程切换的能恢复到正确的执行位置，每条线程都需要又一个独立的程序计数器，在线程私有内存中。
<span class="anchor" id="line-4-9"></span>2. Java 虚拟机栈 ， 与程序计数器一样，这也是线程私有的，生命周期与线程相同，描述的是Java方法执行的内存模型，每个方法在执行的时候都会创建一个Stack Frame，栈桢存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行的过程，就对应了一个栈桢在虚拟机栈中从入栈到出栈的过程。
<span class="anchor" id="line-5-9"></span>3. 本地方法栈。 与虚拟机栈发挥的作用比较相似，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法，也就是字节码的服务，本地方法栈则为虚拟机使用的Native方法服务，有的虚拟机Sun HotSpot 会把这两个合二为一。
<span class="anchor" id="line-6-8"></span>4. Java 堆， 垃圾回收的主要区域，绝大部分对象都会分配到堆上。 堆中还可细分为新生代和老年代，Eden 区，From Survivor吗， To Survivor， 老年代。 线程共享的Java堆中还会分出多个线程私有的分配缓冲区域，TLAB。 映射在物理上可以不连续，只要逻辑上是连续的就行。
<span class="anchor" id="line-7-8"></span>5. 方法区， 与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。  有些人也把这里叫做永久代。无法满足分配时会出发OOM。
<span class="anchor" id="line-8-7"></span>方法区还有个叫做运行常量池的地方，存放编译期生成的各种字面量和符号引用。
<span class="anchor" id="line-9-5"></span>
<span class="anchor" id="line-10-4"></span>* 堆和栈
<span class="anchor" id="line-11-4"></span>* 直接内存/Direct Memory
<span class="anchor" id="line-12-4"></span>
<span class="anchor" id="line-13-3"></span>直接内存： 不是Java虚拟机运行时的数据区域，但是也被频发使用，也可能导致OOM。 和NIO关联密切，Channel 与缓冲区，的IO方式，可以使Native函数库直接操作分配堆外内存，通过一个存储在Java堆中的DirectByBuffer 对象作为这块内存的引用，避免来回复制数据，显著提高性能。
<span class="anchor" id="line-14-3"></span>
<span class="anchor" id="line-15-2"></span>* 对象创建过程
<span class="anchor" id="line-16-2"></span>    * 新建对象的方式
<span class="anchor" id="line-17-2"></span>    先去常量池检查这个符号引用代表的类是不是已经被加载，解析和初始化过。 如果没有先执行相应的类加载过程
<span class="anchor" id="line-18-2"></span>    类加载检查通过后，虚拟机为对象进行分配内存，这里有“指针碰撞” 和 “空闲链表两种方法” 分别对应Java GC 的不同垃圾回收机制 ，compact 和 sweep    
<span class="anchor" id="line-19-2"></span>    分配完后，对对象进行必要的设置，例如是哪个类的实例， 对象的Hash, 对象的GC分代年龄信息。
<span class="anchor" id="line-20-2"></span>    这些做完之后，从Java程序员的角度 新建才刚刚开始，所有字段还都是零。 随后进行初始化。
<span class="anchor" id="line-21-2"></span>    
<span class="anchor" id="line-22-2"></span>* 如何处理并发？
<span class="anchor" id="line-23-1"></span>     1. 使用CAS 平分配方式，保证更新操作。
<span class="anchor" id="line-24-1"></span>     2. 另一种是把内存分配的动作， 按照线程划分在不同的区域，TLAB。
<span class="anchor" id="line-25-1"></span>
<span class="anchor" id="line-26-1"></span>* 对象内存布局
<span class="anchor" id="line-27-1"></span>    * 对象头 header
<span class="anchor" id="line-28-1"></span>        * Mark Word和类型指针    （对象Hash 码， 对象分代年龄 锁记录指针，重量级锁指针）
<span class="anchor" id="line-29-1"></span>    * 实例数据 instance data 真正存储的信息，各个定义的字段
<span class="anchor" id="line-30-1"></span>    * 对齐填充 padding  8字节整数倍</pre><span class="anchor" id="line-627"></span><span class="anchor" id="line-628"></span><p class="line867"><span class="anchor" id="line-629"></span><span class="anchor" id="line-630"></span><span class="anchor" id="line-631"></span><span class="anchor" id="line-632"></span><span class="anchor" id="line-633"></span><span class="anchor" id="line-634"></span><span class="anchor" id="line-635"></span><span class="anchor" id="line-636"></span><span class="anchor" id="line-637"></span><span class="anchor" id="line-638"></span><span class="anchor" id="line-639"></span><span class="anchor" id="line-640"></span><span class="anchor" id="line-641"></span><span class="anchor" id="line-642"></span><span class="anchor" id="line-643"></span><span class="anchor" id="line-644"></span><span class="anchor" id="line-645"></span><span class="anchor" id="line-646"></span><span class="anchor" id="line-647"></span><span class="anchor" id="line-648"></span><span class="anchor" id="line-649"></span><span class="anchor" id="line-650"></span><span class="anchor" id="line-651"></span><span class="anchor" id="line-652"></span><span class="anchor" id="line-653"></span><span class="anchor" id="line-654"></span><span class="anchor" id="line-655"></span><span class="anchor" id="line-656"></span><span class="anchor" id="line-657"></span><span class="anchor" id="line-658"></span><pre><span class="anchor" id="line-1-12"></span>### 垃圾收集
<span class="anchor" id="line-2-12"></span>* 概念和作用
<span class="anchor" id="line-3-11"></span>* 引用计数算法
<span class="anchor" id="line-4-10"></span>* 可达性分析算法
<span class="anchor" id="line-5-10"></span>    * GC Roots
<span class="anchor" id="line-6-9"></span>    1. 虚拟机栈中引用的对象
<span class="anchor" id="line-7-9"></span>    2 方法区中，类静态属性引用的对象
<span class="anchor" id="line-8-8"></span>    3 方法区中， 常量引用的对象
<span class="anchor" id="line-9-6"></span>    4 本地方法栈中JNI引用的对象
<span class="anchor" id="line-10-5"></span>
<span class="anchor" id="line-11-5"></span>    * 引用类型
<span class="anchor" id="line-12-5"></span>    强引用， 引用在就永远不会被回收
<span class="anchor" id="line-13-4"></span>    软引用，在系统即将要发生内存溢出异常之前，会把这些对象列进回收范围中进行二次回收
<span class="anchor" id="line-14-4"></span>    弱引用， 关联的对象只能生存到下一次垃圾收集之前，垃圾回收的时候，无论当前内存是否足够，都会回收掉只被弱引用关联的对象
<span class="anchor" id="line-15-3"></span>    虚引用， 无法通过虚引用获取对象实例，唯一目的就是对象回收时候会获得一个通知。
<span class="anchor" id="line-16-3"></span>
<span class="anchor" id="line-17-3"></span>    * 方法区需要回收吗？
<span class="anchor" id="line-18-3"></span>    需要， 废弃的常量和无用的类，（没有实例， 加载该类的ClassLoader已经回收，无法在任何位置通过反射访问该类的方法）
<span class="anchor" id="line-19-3"></span>
<span class="anchor" id="line-20-3"></span>* 常用收集算法
<span class="anchor" id="line-21-3"></span>    * 标记-清除 Mark-Sweep
<span class="anchor" id="line-22-3"></span>    * 复制算法
<span class="anchor" id="line-23-2"></span>    * 标记-整理 Mark-Compact
<span class="anchor" id="line-24-2"></span>    * 分代收集
<span class="anchor" id="line-25-2"></span>        * 新生代和老年代
<span class="anchor" id="line-26-2"></span>        * 永久代(Permanent Generation)和Metaspace
<span class="anchor" id="line-27-2"></span>* 安全点和安全区域 
<span class="anchor" id="line-28-2"></span>
<span class="anchor" id="line-29-2"></span>安全区域解决线程sleep blocked无法中断的问题，提供一块区域，到安全区挂起。</pre><span class="anchor" id="line-659"></span><p class="line867"><span class="anchor" id="line-660"></span><span class="anchor" id="line-661"></span><span class="anchor" id="line-662"></span><span class="anchor" id="line-663"></span><span class="anchor" id="line-664"></span><span class="anchor" id="line-665"></span><span class="anchor" id="line-666"></span><span class="anchor" id="line-667"></span><span class="anchor" id="line-668"></span><span class="anchor" id="line-669"></span><span class="anchor" id="line-670"></span><span class="anchor" id="line-671"></span><span class="anchor" id="line-672"></span><span class="anchor" id="line-673"></span><span class="anchor" id="line-674"></span><span class="anchor" id="line-675"></span><span class="anchor" id="line-676"></span><span class="anchor" id="line-677"></span><span class="anchor" id="line-678"></span><span class="anchor" id="line-679"></span><span class="anchor" id="line-680"></span><span class="anchor" id="line-681"></span><span class="anchor" id="line-682"></span><span class="anchor" id="line-683"></span><span class="anchor" id="line-684"></span><span class="anchor" id="line-685"></span><span class="anchor" id="line-686"></span><span class="anchor" id="line-687"></span><pre><span class="anchor" id="line-1-13"></span>### 垃圾收集器
<span class="anchor" id="line-2-13"></span>* 常用收集器
<span class="anchor" id="line-3-12"></span>    * Serial  
<span class="anchor" id="line-4-11"></span>    Stop the world 关掉所有线程，
<span class="anchor" id="line-5-11"></span>    优点，1. 简单高效，适合单核处理器，2 。 没有线程交互开销
<span class="anchor" id="line-6-10"></span>    
<span class="anchor" id="line-7-10"></span>   * Serial Old 
<span class="anchor" id="line-8-9"></span>   * ParNew
<span class="anchor" id="line-9-7"></span>    ParNew /SERIAL OLD 模型
<span class="anchor" id="line-10-6"></span>
<span class="anchor" id="line-11-6"></span>    * Parallel Scavenge  侧重于吞吐量 ，控制最大垃圾收集停顿时间-XX:MaxGCPauseMillis 直接设置吞吐量大小 -XX:GCTImeRatio
<span class="anchor" id="line-12-6"></span>     新生代收集器
<span class="anchor" id="line-13-5"></span>     
<span class="anchor" id="line-14-5"></span>   *Parallel Old
<span class="anchor" id="line-15-4"></span>    Parallel Old Parallel Scavenge 的老年版本
<span class="anchor" id="line-16-4"></span>    
<span class="anchor" id="line-17-4"></span>    * CMS
<span class="anchor" id="line-18-4"></span>    目标：获取最短停顿时间
<span class="anchor" id="line-19-4"></span>    初始标记（标记GC直接关联的对象），并发标记（进行GC root tracing），重新标记（标记期间，用户程序继续运行的改动）， 前两个阶段仍然是stop the world 
<span class="anchor" id="line-20-4"></span>    缺点： 对CPU资源要求敏感，无法处理浮动垃圾（运行时产生的垃圾），采用标记清除会产生碎片
<span class="anchor" id="line-21-4"></span>
<span class="anchor" id="line-22-4"></span>    
<span class="anchor" id="line-23-3"></span>    * G1
<span class="anchor" id="line-24-3"></span>* Minor GC/Major GC/Mixed GC/Full GC
<span class="anchor" id="line-25-3"></span>    * jstat里列出的GC指的是STW
<span class="anchor" id="line-26-3"></span>    * gc log则是列出了所有的信息
<span class="anchor" id="line-27-3"></span>* 垃圾收集与RAII的比较 *</pre><p class="line874"> <span class="anchor" id="line-688"></span><span class="anchor" id="line-689"></span><p class="line874">{{ <span class="anchor" id="line-690"></span><span class="anchor" id="line-691"></span><p class="line874">* 结构 <span class="anchor" id="line-692"></span><ul><li>魔数与版本 <span class="anchor" id="line-693"></span></li><li>常量池 <span class="anchor" id="line-694"></span></li><li>访问标志 <span class="anchor" id="line-695"></span></li><li>类索引、父类索引与接口索引 <span class="anchor" id="line-696"></span></li><li>字段表 <span class="anchor" id="line-697"></span></li><li>方法表 <span class="anchor" id="line-698"></span></li></ul><p class="line867"><span class="u">_ <span class="anchor" id="line-699"></span>}} <span class="anchor" id="line-700"></span><span class="anchor" id="line-701"></span><p class="line867"><span class="anchor" id="line-702"></span><span class="anchor" id="line-703"></span><span class="anchor" id="line-704"></span><span class="anchor" id="line-705"></span><span class="anchor" id="line-706"></span><span class="anchor" id="line-707"></span><span class="anchor" id="line-708"></span><span class="anchor" id="line-709"></span><span class="anchor" id="line-710"></span><span class="anchor" id="line-711"></span><span class="anchor" id="line-712"></span><pre><span class="anchor" id="line-1-14"></span>### 类加载
<span class="anchor" id="line-2-14"></span>* 加载过程
<span class="anchor" id="line-3-13"></span>    * 加载
<span class="anchor" id="line-4-12"></span>    * 连接 - 验证，准备，解析
<span class="anchor" id="line-5-12"></span>    * 初始化
<span class="anchor" id="line-6-11"></span>        * &lt;clinit&gt;()和&lt;init&gt;()
<span class="anchor" id="line-7-11"></span>    * 使用
<span class="anchor" id="line-8-10"></span>    * 卸载
<span class="anchor" id="line-9-8"></span>* 虚拟机严格规定了初始化的场景（主动引用）
<span class="anchor" id="line-10-7"></span>* 类加载器的双亲委派模型
<span class="anchor" id="line-11-7"></span>* 怎么判断两个类相同</pre><span class="anchor" id="line-713"></span><span class="anchor" id="line-714"></span><p class="line867"><span class="anchor" id="line-715"></span><span class="anchor" id="line-716"></span><span class="anchor" id="line-717"></span><span class="anchor" id="line-718"></span><span class="anchor" id="line-719"></span><span class="anchor" id="line-720"></span><span class="anchor" id="line-721"></span><span class="anchor" id="line-722"></span><span class="anchor" id="line-723"></span><span class="anchor" id="line-724"></span><span class="anchor" id="line-725"></span><span class="anchor" id="line-726"></span><pre><span class="anchor" id="line-1-15"></span>### 执行字节码
<span class="anchor" id="line-2-15"></span>* 栈帧
<span class="anchor" id="line-3-14"></span>    * 局部变量表
<span class="anchor" id="line-4-13"></span>    * 操作数栈
<span class="anchor" id="line-5-13"></span>    * 返回地址
<span class="anchor" id="line-6-12"></span>* 方法调用
<span class="anchor" id="line-7-12"></span>    * 解析调用
<span class="anchor" id="line-8-11"></span>    * 分派调用
<span class="anchor" id="line-9-9"></span>        * 静态 vs 动态
<span class="anchor" id="line-10-8"></span>        * 单分派 vs 多分派
<span class="anchor" id="line-11-8"></span>* 基于栈 vs 基于寄存器</pre><span class="anchor" id="line-727"></span><span class="anchor" id="line-728"></span><p class="line867"><span class="anchor" id="line-729"></span><span class="anchor" id="line-730"></span><span class="anchor" id="line-731"></span><span class="anchor" id="line-732"></span><span class="anchor" id="line-733"></span><span class="anchor" id="line-734"></span><span class="anchor" id="line-735"></span><span class="anchor" id="line-736"></span><span class="anchor" id="line-737"></span><span class="anchor" id="line-738"></span><span class="anchor" id="line-739"></span><span class="anchor" id="line-740"></span><span class="anchor" id="line-741"></span><span class="anchor" id="line-742"></span><span class="anchor" id="line-743"></span><span class="anchor" id="line-744"></span><span class="anchor" id="line-745"></span><span class="anchor" id="line-746"></span><span class="anchor" id="line-747"></span><span class="anchor" id="line-748"></span><span class="anchor" id="line-749"></span><span class="anchor" id="line-750"></span><span class="anchor" id="line-751"></span><span class="anchor" id="line-752"></span><span class="anchor" id="line-753"></span><span class="anchor" id="line-754"></span><pre><span class="anchor" id="line-1-16"></span>### 编译
<span class="anchor" id="line-2-16"></span>* AOT
<span class="anchor" id="line-3-15"></span>    * 前端/优化器/后端
<span class="anchor" id="line-4-14"></span>* Javac
<span class="anchor" id="line-5-14"></span>
<span class="anchor" id="line-6-13"></span>---
<span class="anchor" id="line-7-13"></span>### 运行时优化
<span class="anchor" id="line-8-12"></span>* 解释器与编译器并存
<span class="anchor" id="line-9-10"></span>    * 分层编译
<span class="anchor" id="line-10-9"></span>    * Server模式和Client模式*
<span class="anchor" id="line-11-9"></span>* 即时编译 JIT
<span class="anchor" id="line-12-7"></span>    * 热点探测 Hot Span Detection
<span class="anchor" id="line-13-6"></span>    * 栈上替换 On Stack Replacement
<span class="anchor" id="line-14-6"></span>* 运行期优化
<span class="anchor" id="line-15-5"></span>
<span class="anchor" id="line-16-5"></span>---
<span class="anchor" id="line-17-5"></span>
<span class="anchor" id="line-18-5"></span>### 编译器 vs 解释器 vs 虚拟机
<span class="anchor" id="line-19-5"></span>
<span class="anchor" id="line-20-5"></span>Override 动态分配
<span class="anchor" id="line-21-5"></span>Overload 静态分配
<span class="anchor" id="line-22-5"></span>参数静态分配
<span class="anchor" id="line-23-4"></span>前面调用的是动态分配</pre><span class="anchor" id="line-755"></span><span class="anchor" id="line-756"></span><span class="anchor" id="line-757"></span><p class="line867">
<h2 id="July_20">July 20</h2>
<span class="anchor" id="line-758"></span><p class="line867">
<h3 id="A.2BlsZPU1tmTmA_JVM.2BjANPGA-">集体学习 JVM调优</h3>
<span class="anchor" id="line-759"></span><p class="line867"><span class="anchor" id="line-760"></span><span class="anchor" id="line-761"></span><span class="anchor" id="line-762"></span><span class="anchor" id="line-763"></span><span class="anchor" id="line-764"></span><span class="anchor" id="line-765"></span><span class="anchor" id="line-766"></span><span class="anchor" id="line-767"></span><span class="anchor" id="line-768"></span><span class="anchor" id="line-769"></span><span class="anchor" id="line-770"></span><span class="anchor" id="line-771"></span><span class="anchor" id="line-772"></span><span class="anchor" id="line-773"></span><span class="anchor" id="line-774"></span><span class="anchor" id="line-775"></span><span class="anchor" id="line-776"></span><span class="anchor" id="line-777"></span><span class="anchor" id="line-778"></span><span class="anchor" id="line-779"></span><span class="anchor" id="line-780"></span><span class="anchor" id="line-781"></span><span class="anchor" id="line-782"></span><span class="anchor" id="line-783"></span><span class="anchor" id="line-784"></span><span class="anchor" id="line-785"></span><span class="anchor" id="line-786"></span><span class="anchor" id="line-787"></span><span class="anchor" id="line-788"></span><span class="anchor" id="line-789"></span><span class="anchor" id="line-790"></span><span class="anchor" id="line-791"></span><span class="anchor" id="line-792"></span><span class="anchor" id="line-793"></span><span class="anchor" id="line-794"></span><span class="anchor" id="line-795"></span><span class="anchor" id="line-796"></span><span class="anchor" id="line-797"></span><span class="anchor" id="line-798"></span><span class="anchor" id="line-799"></span><span class="anchor" id="line-800"></span><span class="anchor" id="line-801"></span><span class="anchor" id="line-802"></span><span class="anchor" id="line-803"></span><span class="anchor" id="line-804"></span><span class="anchor" id="line-805"></span><span class="anchor" id="line-806"></span><span class="anchor" id="line-807"></span><span class="anchor" id="line-808"></span><span class="anchor" id="line-809"></span><span class="anchor" id="line-810"></span><span class="anchor" id="line-811"></span><span class="anchor" id="line-812"></span><span class="anchor" id="line-813"></span><span class="anchor" id="line-814"></span><span class="anchor" id="line-815"></span><span class="anchor" id="line-816"></span><span class="anchor" id="line-817"></span><span class="anchor" id="line-818"></span><span class="anchor" id="line-819"></span><span class="anchor" id="line-820"></span><pre><span class="anchor" id="line-1-17"></span>调优目的： 吞吐量， 延迟，内存占用 
<span class="anchor" id="line-2-17"></span>调优参数：性能参数，行为参数，调试参数
<span class="anchor" id="line-3-16"></span>调优远离： 和 垃圾回收机制有关
<span class="anchor" id="line-4-15"></span>-Xmn -&gt;新生代内存
<span class="anchor" id="line-5-15"></span>-Xms -&gt;JVM 启动时候可申请的最小内存
<span class="anchor" id="line-6-14"></span>-Xmx -&gt;JVM 可申请的最大heap内存
<span class="anchor" id="line-7-14"></span>-XX: SurvivorRation-&gt;Eden 和S0 或者 S1 区的比例
<span class="anchor" id="line-8-13"></span>-XX: NewRatio 新生到和老年代比例
<span class="anchor" id="line-9-11"></span>-XX: NewSize 新生代空间
<span class="anchor" id="line-10-10"></span>-XX: MaxTenringThreshold: 对象进入老年的年龄阈值
<span class="anchor" id="line-11-10"></span>-XX:-UseSerialGC, serial&amp;serial old      (client默认模式)
<span class="anchor" id="line-12-8"></span>-XX:-UseParallelGC,  parallel scavenge&amp; parral old  server默认模式
<span class="anchor" id="line-13-7"></span>-XX:-UseConcMarkSweepGC,  ParNew+CMS
<span class="anchor" id="line-14-7"></span>XX:+UseG1GC
<span class="anchor" id="line-15-6"></span>
<span class="anchor" id="line-16-6"></span>jps: 查看jvm进程
<span class="anchor" id="line-17-6"></span>jmap：提供 JVM 内存使用信息，适用于脚本中。
<span class="anchor" id="line-18-6"></span>jmap
<span class="anchor" id="line-19-6"></span>
<span class="anchor" id="line-20-6"></span>用于显示当前Java堆和永久代的详细信息（如当前使用的收集器，当前的空间使用率等）
<span class="anchor" id="line-21-6"></span>   -dump:生成java堆转储快照
<span class="anchor" id="line-22-6"></span>   -heap:显示java堆详细信息(只在Linux/Solaris下有效)
<span class="anchor" id="line-23-5"></span>   -F:当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照(只在Linux/Solaris下有效)
<span class="anchor" id="line-24-4"></span>   -finalizerinfo:显示在F-Queue中等待Finalizer线程执行finalize方法的对象(只在Linux/Solaris下有效)
<span class="anchor" id="line-25-4"></span>   -histo:显示堆中对象统计信息
<span class="anchor" id="line-26-4"></span>   -permstat:以ClassLoader为统计口径显示永久代内存状态(只在Linux/Solaris下有效
<span class="anchor" id="line-27-4"></span> 命令格式:jmap [option] vmid
<span class="anchor" id="line-28-3"></span>
<span class="anchor" id="line-29-3"></span>jinfo：访问 JVM 系统属性，同时可以动态修改这些属性。
<span class="anchor" id="line-30-2"></span>jstack：提供 Java 进程内的线程堆栈信息。
<span class="anchor" id="line-31-1"></span>jstack
<span class="anchor" id="line-32-1"></span>用于生成当前JVM的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法,目的是定位线程出现长时间停顿的原因。
<span class="anchor" id="line-33-1"></span>   -F:当正常输出的请求不被响应时，强制输出线程堆栈
<span class="anchor" id="line-34-1"></span>   -l:除堆栈外，显示关于锁的附加信息
<span class="anchor" id="line-35-1"></span>   -m:如果调用到本地方法的话，可以显示C/C++的堆栈
<span class="anchor" id="line-36-1"></span>命令格式:jstack [option] vmid
<span class="anchor" id="line-37-1"></span>
<span class="anchor" id="line-38-1"></span> 
<span class="anchor" id="line-39-1"></span>jstat：提供 Java 垃圾回收以及类加载信息。
<span class="anchor" id="line-40-1"></span>jstat可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据
<span class="anchor" id="line-41-1"></span>   -class:监视类装载、卸载数量、总空间及类装载所耗费的时间
<span class="anchor" id="line-42-1"></span>   -gc:监听Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量，以用空间、GC时间合计等信息
<span class="anchor" id="line-43-1"></span>   -gccapacity:监视内容与-gc基本相同，但输出主要关注java堆各个区域使用到的最大和最小空间
<span class="anchor" id="line-44-1"></span>   -gcutil:监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比
<span class="anchor" id="line-45-1"></span>   -gccause:与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因
<span class="anchor" id="line-46-1"></span>   -gcnew:监视新生代GC状况
<span class="anchor" id="line-47-1"></span>   -gcnewcapacity:监视内同与-gcnew基本相同，输出主要关注使用到的最大和最小空间
<span class="anchor" id="line-48-1"></span>   -gcold:监视老年代GC情况
<span class="anchor" id="line-49-1"></span>
<span class="anchor" id="line-50-1"></span>jconsole：提供 JVM 活动的图形化展示，包括线程使用，类使用以及垃圾回收（GC）信息。
<span class="anchor" id="line-51-1"></span>Java mission control
<span class="anchor" id="line-52-1"></span>Memory analyzer tool
<span class="anchor" id="line-53-1"></span>远程调试
<span class="anchor" id="line-54-1"></span>
<span class="anchor" id="line-55-1"></span>
<span class="anchor" id="line-56-1"></span>-verbosegc配合使用的一些常用参数为：
<span class="anchor" id="line-57-1"></span>   -XX:+PrintGCDetails，打印GC信息，这是-verbosegc默认开启的选项
<span class="anchor" id="line-58-1"></span>   -XX:+PrintGCTimeStamps，打印每次GC的时间戳
<span class="anchor" id="line-59-1"></span>   -XX:+PrintHeapAtGC：每次GC时，打印堆信息
<span class="anchor" id="line-60-1"></span>   -XX:+PrintGCDateStamps (from JDK 6 update 4) ：打印GC日期，适合于长期运行的服务器</pre><span class="anchor" id="line-821"></span><span class="anchor" id="line-822"></span><p class="line867">
<h2 id="July_21-26">July 21-26</h2>
<span class="anchor" id="line-823"></span><p class="line867">
<h3 id="Redis_.2BThpSoVtmTmA-">Redis 业务学习</h3>
<span class="anchor" id="line-824"></span><p class="line867"><span class="anchor" id="line-825"></span><span class="anchor" id="line-826"></span><span class="anchor" id="line-827"></span><span class="anchor" id="line-828"></span><span class="anchor" id="line-829"></span><span class="anchor" id="line-830"></span><span class="anchor" id="line-831"></span><span class="anchor" id="line-832"></span><span class="anchor" id="line-833"></span><span class="anchor" id="line-834"></span><pre><span class="anchor" id="line-1-18"></span>redis单线程
<span class="anchor" id="line-2-18"></span>支持两种数据持久化方式：Snapshotting（快照）和 Append Only file（追加到日志记录文件）
<span class="anchor" id="line-3-17"></span>Redis是一个高性能的 key-value 对存储系统。它支持存储的value类型很多，包括string（字符串）、list（链表）、hash（哈希）、set（无序集合）、zset（有序集合）
<span class="anchor" id="line-4-16"></span>支持两种数据持久化方式：Snapshotting（快照）和 Append Only file（追加到日志记录文件）
<span class="anchor" id="line-5-16"></span>
<span class="anchor" id="line-6-15"></span>关于并发
<span class="anchor" id="line-7-15"></span>如果你的所有操作都是靠redis本身的机制保持原子性 不要锁也可以
<span class="anchor" id="line-8-14"></span>如果存在读数据，写redis要保证这个数据在并发的时候是一致的。</pre><span class="anchor" id="line-835"></span><p class="line867">
<h3 id="New-Bull_.2BXnZT0X8Wegt1MW1FUWVt8Q-">New-Bull 并发编程由浅入深</h3>
<span class="anchor" id="line-836"></span><p class="line867"><span class="anchor" id="line-837"></span><span class="anchor" id="line-838"></span><span class="anchor" id="line-839"></span><span class="anchor" id="line-840"></span><span class="anchor" id="line-841"></span><span class="anchor" id="line-842"></span><span class="anchor" id="line-843"></span><span class="anchor" id="line-844"></span><span class="anchor" id="line-845"></span><span class="anchor" id="line-846"></span><span class="anchor" id="line-847"></span><span class="anchor" id="line-848"></span><span class="anchor" id="line-849"></span><span class="anchor" id="line-850"></span><span class="anchor" id="line-851"></span><span class="anchor" id="line-852"></span><span class="anchor" id="line-853"></span><span class="anchor" id="line-854"></span><span class="anchor" id="line-855"></span><span class="anchor" id="line-856"></span><span class="anchor" id="line-857"></span><span class="anchor" id="line-858"></span><span class="anchor" id="line-859"></span><span class="anchor" id="line-860"></span><span class="anchor" id="line-861"></span><span class="anchor" id="line-862"></span><span class="anchor" id="line-863"></span><span class="anchor" id="line-864"></span><span class="anchor" id="line-865"></span><span class="anchor" id="line-866"></span><span class="anchor" id="line-867"></span><span class="anchor" id="line-868"></span><span class="anchor" id="line-869"></span><span class="anchor" id="line-870"></span><span class="anchor" id="line-871"></span><span class="anchor" id="line-872"></span><span class="anchor" id="line-873"></span><span class="anchor" id="line-874"></span><span class="anchor" id="line-875"></span><span class="anchor" id="line-876"></span><span class="anchor" id="line-877"></span><span class="anchor" id="line-878"></span><span class="anchor" id="line-879"></span><span class="anchor" id="line-880"></span><span class="anchor" id="line-881"></span><span class="anchor" id="line-882"></span><span class="anchor" id="line-883"></span><span class="anchor" id="line-884"></span><span class="anchor" id="line-885"></span><span class="anchor" id="line-886"></span><span class="anchor" id="line-887"></span><span class="anchor" id="line-888"></span><span class="anchor" id="line-889"></span><span class="anchor" id="line-890"></span><span class="anchor" id="line-891"></span><span class="anchor" id="line-892"></span><span class="anchor" id="line-893"></span><span class="anchor" id="line-894"></span><span class="anchor" id="line-895"></span><span class="anchor" id="line-896"></span><span class="anchor" id="line-897"></span><span class="anchor" id="line-898"></span><span class="anchor" id="line-899"></span><span class="anchor" id="line-900"></span><span class="anchor" id="line-901"></span><span class="anchor" id="line-902"></span><span class="anchor" id="line-903"></span><span class="anchor" id="line-904"></span><span class="anchor" id="line-905"></span><span class="anchor" id="line-906"></span><span class="anchor" id="line-907"></span><span class="anchor" id="line-908"></span><span class="anchor" id="line-909"></span><span class="anchor" id="line-910"></span><span class="anchor" id="line-911"></span><span class="anchor" id="line-912"></span><span class="anchor" id="line-913"></span><span class="anchor" id="line-914"></span><span class="anchor" id="line-915"></span><span class="anchor" id="line-916"></span><span class="anchor" id="line-917"></span><span class="anchor" id="line-918"></span><span class="anchor" id="line-919"></span><span class="anchor" id="line-920"></span><span class="anchor" id="line-921"></span><span class="anchor" id="line-922"></span><span class="anchor" id="line-923"></span><span class="anchor" id="line-924"></span><span class="anchor" id="line-925"></span><span class="anchor" id="line-926"></span><span class="anchor" id="line-927"></span><span class="anchor" id="line-928"></span><span class="anchor" id="line-929"></span><span class="anchor" id="line-930"></span><span class="anchor" id="line-931"></span><span class="anchor" id="line-932"></span><span class="anchor" id="line-933"></span><span class="anchor" id="line-934"></span><span class="anchor" id="line-935"></span><span class="anchor" id="line-936"></span><span class="anchor" id="line-937"></span><span class="anchor" id="line-938"></span><span class="anchor" id="line-939"></span><span class="anchor" id="line-940"></span><span class="anchor" id="line-941"></span><span class="anchor" id="line-942"></span><span class="anchor" id="line-943"></span><span class="anchor" id="line-944"></span><span class="anchor" id="line-945"></span><span class="anchor" id="line-946"></span><span class="anchor" id="line-947"></span><span class="anchor" id="line-948"></span><span class="anchor" id="line-949"></span><pre><span class="anchor" id="line-1-19"></span>### 基本概念
<span class="anchor" id="line-2-19"></span> * 并发与并行
<span class="anchor" id="line-3-18"></span> * 讨论: 写对并发代码的挑战
<span class="anchor" id="line-4-17"></span>1. 设计好共享状态
<span class="anchor" id="line-5-17"></span>2.  状态设计. 以Servlet 为例， servlet 是共享的. “Servlet 要无状态
<span class="anchor" id="line-6-16"></span>3. 时序的问题
<span class="anchor" id="line-7-16"></span>4. 优化为了达到线程安全所花费的开销，主要是锁
<span class="anchor" id="line-8-15"></span>
<span class="anchor" id="line-9-12"></span>什么是线程安全的？
<span class="anchor" id="line-10-11"></span>一个模块是线程安全，多线程调它的接 ，结果逻辑正确/符合预期.
<span class="anchor" id="line-11-11"></span>要求调 者需要加锁、需要某种时序的保证
<span class="anchor" id="line-12-9"></span>
<span class="anchor" id="line-13-8"></span>坑： RMW. Read-Modify-Write
<span class="anchor" id="line-14-8"></span>典型的坑：
<span class="anchor" id="line-15-7"></span>case 1: ConcurrentModificationException
<span class="anchor" id="line-16-7"></span>fail fast : ArrayList.checkForComodification()
<span class="anchor" id="line-17-7"></span>https://coolshell.cn/articles/9606.html rehash 导致hashmap死循环
<span class="anchor" id="line-18-7"></span>内存缓存 deepCopy()
<span class="anchor" id="line-19-7"></span>
<span class="anchor" id="line-20-7"></span>为什么要有并发？ 利用多核， 设计上贴近现实世界。
<span class="anchor" id="line-21-7"></span>---
<span class="anchor" id="line-22-7"></span>
<span class="anchor" id="line-23-6"></span>### 几个核心概念
<span class="anchor" id="line-24-5"></span> * 原子操作 : 并发场景的基本需求， 也是互斥、同步 实现的前提
<span class="anchor" id="line-25-5"></span> * 互斥 : 并发场景的基本需求
<span class="anchor" id="line-26-5"></span> * 同步 : 并发实体之间的通讯
<span class="anchor" id="line-27-5"></span> * 可见性 : 解决底层并发性能优化带来的副作用
<span class="anchor" id="line-28-4"></span>
<span class="anchor" id="line-29-4"></span>原子操作；  boolean Unsafe.compareAndSwap /Unsafe.objectFieldOffset(AtomicInteger.field(“value”))
<span class="anchor" id="line-30-3"></span>常见的互斥机制 ? 锁 信号量 Synchronized
<span class="anchor" id="line-31-2"></span>同步 Object.wait Object.notify 
<span class="anchor" id="line-32-2"></span>Lock.condition
<span class="anchor" id="line-33-2"></span> notify/signal 还是 notifyAll/signalAll 
<span class="anchor" id="line-34-2"></span>避免liveness VS “惊群效应” (thundering herd)
<span class="anchor" id="line-35-2"></span>
<span class="anchor" id="line-36-2"></span>可见性 — Java
<span class="anchor" id="line-37-2"></span>内存屏障
<span class="anchor" id="line-38-2"></span>
<span class="anchor" id="line-39-2"></span>同步 : 并发实体之间的通讯
<span class="anchor" id="line-40-2"></span>可 性 : 解决底层并发性能优化带来的副作 
<span class="anchor" id="line-41-2"></span>
<span class="anchor" id="line-42-2"></span>### 原子操作
<span class="anchor" id="line-43-2"></span> * CAS, CompareAndSwap
<span class="anchor" id="line-44-2"></span> * Java 原子操作的支持
<span class="anchor" id="line-45-2"></span>
<span class="anchor" id="line-46-2"></span>---
<span class="anchor" id="line-47-2"></span>
<span class="anchor" id="line-48-2"></span>### 互斥
<span class="anchor" id="line-49-2"></span> * 常见的互斥机制
<span class="anchor" id="line-50-2"></span> * Java 互斥机制的相关实现
<span class="anchor" id="line-51-2"></span>
<span class="anchor" id="line-52-2"></span>---
<span class="anchor" id="line-53-2"></span>
<span class="anchor" id="line-54-2"></span>### 同步
<span class="anchor" id="line-55-2"></span> * Object .wait() .notify()
<span class="anchor" id="line-56-2"></span> * Lock.condition
<span class="anchor" id="line-57-2"></span> * Future
<span class="anchor" id="line-58-2"></span> * 一些Helper类:  Semaphore, CountDownLatch 等
<span class="anchor" id="line-59-2"></span>
<span class="anchor" id="line-60-2"></span>---
<span class="anchor" id="line-61-1"></span>
<span class="anchor" id="line-62-1"></span>### 可见性
<span class="anchor" id="line-63-1"></span> * 可见性问题存在的原因
<span class="anchor" id="line-64-1"></span> * volatile. 内存屏障. Java 内存模型
<span class="anchor" id="line-65-1"></span>
<span class="anchor" id="line-66-1"></span>---
<span class="anchor" id="line-67-1"></span>
<span class="anchor" id="line-68-1"></span>### Concurrent Collection
<span class="anchor" id="line-69-1"></span>
<span class="anchor" id="line-70-1"></span>---
<span class="anchor" id="line-71-1"></span>
<span class="anchor" id="line-72-1"></span>### Java 线程池实现 ThreadPoolExecutor
<span class="anchor" id="line-73-1"></span> * 运行机制剖析
<span class="anchor" id="line-74-1"></span> * 使用原则
<span class="anchor" id="line-75-1"></span>
<span class="anchor" id="line-76-1"></span>为了线程复用以及控制资源开销
<span class="anchor" id="line-77-1"></span>
<span class="anchor" id="line-78-1"></span>各个参数意义：
<span class="anchor" id="line-79-1"></span>当execute(task) 时:
<span class="anchor" id="line-80-1"></span>如果当前线程数 &lt; corePoolSize, 则创建新线程. ( 即使当前线程中有idle的 /!\ )
<span class="anchor" id="line-81-1"></span>
<span class="anchor" id="line-82-1"></span>如过当前线程数 &gt;= corePoolSize, 则进队列. ( idle 的线程会从队列取task )
<span class="anchor" id="line-83"></span>
<span class="anchor" id="line-84"></span>如果队列满了且当前线程数 &lt; maxPoolSize, 则新建线程来处理
<span class="anchor" id="line-85"></span>
<span class="anchor" id="line-86"></span>否则 调用 RejectedExecutionHandler 进行处理
<span class="anchor" id="line-87"></span>
<span class="anchor" id="line-88"></span>keepAliveTime
<span class="anchor" id="line-89"></span>&gt; coreSize &lt; maxSize 的线程在ilde时间超过这个阈值时会被销毁
<span class="anchor" id="line-90"></span>
<span class="anchor" id="line-91"></span>pool.allowCoreThreadTimeOut(true) 可使得 &lt;= coreSize 的线程也参照这个keepActiveTime
<span class="anchor" id="line-92"></span>
<span class="anchor" id="line-93"></span>队列
<span class="anchor" id="line-94"></span>队列的类型用于在 资源控制 和 吞吐之间做权衡
<span class="anchor" id="line-95"></span>不限制capacity 的 LinkedBlockingQueue, 则maxSize无效. 吞吐受限于coreSize, 也减少了线程的创建及context switch 等开销.
<span class="anchor" id="line-96"></span>
<span class="anchor" id="line-97"></span>SynchronousQueue. 如果有当前thread有idle的则可 "进队列" (特殊的长度为0的队列)， 否则创建新的线程. 保证了吞吐
<span class="anchor" id="line-98"></span>
<span class="anchor" id="line-99"></span>ArrayBlockingQueue, 上两种队列的一种平衡
<span class="anchor" id="line-100"></span>
<span class="anchor" id="line-101"></span>
<span class="anchor" id="line-102"></span>---
<span class="anchor" id="line-103"></span>
<span class="anchor" id="line-104"></span>### ForkjoinPool 框架及 ParallelStream
<span class="anchor" id="line-105"></span>Map &amp; Reduce = Divide &amp; Conquer = Fork &amp; Join
<span class="anchor" id="line-106"></span>---
<span class="anchor" id="line-107"></span>
<span class="anchor" id="line-108"></span>### 其它
<span class="anchor" id="line-109"></span> * ThreadLocal
<span class="anchor" id="line-110"></span></pre><span class="anchor" id="line-950"></span><span class="anchor" id="line-951"></span><p class="line867">
<h3 id="A.2Bfud.2B7Q-Tutor-team_.2BThpSoWV0dAY-">继续Tutor-team 业务整理</h3>
<span class="anchor" id="line-952"></span><span class="anchor" id="line-953"></span><p class="line867">
<h2 id="July_29">July 29</h2>
<span class="anchor" id="line-954"></span><p class="line867">
<h3 id="A.2BTgNZKU4Di.2B2KAA-">七天七语言</h3>
<span class="anchor" id="line-955"></span><p class="line874">主要就是学习到了其他语言的一些编程思想 <span class="anchor" id="line-956"></span><span class="anchor" id="line-957"></span><span class="anchor" id="line-958"></span><span class="anchor" id="line-959"></span><span class="anchor" id="line-960"></span><span class="anchor" id="line-961"></span><span class="anchor" id="line-962"></span><span class="anchor" id="line-963"></span><span class="anchor" id="line-964"></span><span class="anchor" id="line-965"></span><span class="anchor" id="line-966"></span><span class="anchor" id="line-967"></span><span class="anchor" id="line-968"></span><pre><span class="anchor" id="line-1-20"></span>闭包是一个函数/方法
<span class="anchor" id="line-2-20"></span>你可以向传递对象那样传递它, 以后调用
<span class="anchor" id="line-3-19"></span>当这个函数创建的时候, 它记住了该环境下所有的变量的值. 被调用时, 它可以一直访问这些变量, 甚至这些变量已处于环境的外部.
<span class="anchor" id="line-4-18"></span>
<span class="anchor" id="line-5-18"></span>语言：
<span class="anchor" id="line-6-17"></span>主要是看是不是在运行期才会报类型不一致错误
<span class="anchor" id="line-7-17"></span>静态类型
<span class="anchor" id="line-8-16"></span>动态类型
<span class="anchor" id="line-9-13"></span>
<span class="anchor" id="line-10-12"></span>鸭子类型 
<span class="anchor" id="line-11-12"></span>behave as a</pre><span class="anchor" id="line-969"></span><span class="anchor" id="line-970"></span><p class="line867">
<h2 id="July_31">July 31</h2>
<span class="anchor" id="line-971"></span><p class="line867">
<h3 id="A.2BZw1SoWV0dAY-">服务整理</h3>
<span class="anchor" id="line-972"></span><p class="line874">主要是team 相关资源的 redis crud操作。 <span class="anchor" id="line-973"></span><span class="anchor" id="line-974"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-975"></span>
<h2 id="Aug_1">Aug 1</h2>
<span class="anchor" id="line-976"></span><p class="line867">
<h3 id="A.2BW2ZOYA-redis.2BdvhRc3UobNU-">学习redis相关用法</h3>
<span class="anchor" id="line-977"></span><p class="line867"><span class="anchor" id="line-978"></span><span class="anchor" id="line-979"></span><pre><span class="anchor" id="line-1-21"></span>用redisClinet.callByRead/callByWrite，免得自己来释放</pre><span class="anchor" id="line-980"></span><span class="anchor" id="line-981"></span><p class="line867">
<h2 id="Aug_2">Aug 2</h2>
<span class="anchor" id="line-982"></span><p class="line867">
<h3 id="A.2BZbByW1tmTmA_--_.2Bi76LoWVwY25bxpbGV4telHUo-">新牛学习 -- 设计数据密集型应用</h3>
<span class="anchor" id="line-983"></span><p class="line874">《设计数据密集型应用》前三章， SST 和 LSM tree <span class="anchor" id="line-984"></span><span class="anchor" id="line-985"></span><span class="anchor" id="line-986"></span><p class="line867">
<h3 id="A.2Bfud.2B7Q-tutor-team.2BZw1SoWV0dAb.2FDGXgV1E-">继续tutor-team服务整理，无坑</h3>
<span class="anchor" id="line-987"></span><span class="anchor" id="line-988"></span><p class="line867">
<h2 id="Aug_3">Aug 3</h2>
<span class="anchor" id="line-989"></span><p class="line867">
<h3 id="A.2BW.2FxR.2Bouoi7pTOmXlX9c-">导出讨论区日志</h3>
<span class="anchor" id="line-990"></span><p class="line867"><span class="anchor" id="line-991"></span><span class="anchor" id="line-992"></span><pre><span class="anchor" id="line-1-22"></span>sql limit offset 第一次使用</pre><span class="anchor" id="line-993"></span><span class="anchor" id="line-994"></span><p class="line867">
<h3 id="A.2BeyxOAGshdTOL9w-redis">第一次申请redis</h3>
<span class="anchor" id="line-995"></span><p class="line874">熟悉提供单，命名规则等 <span class="anchor" id="line-996"></span><span class="anchor" id="line-997"></span><p class="line867">
<h2 id="Aug_4">Aug 4</h2>
<span class="anchor" id="line-998"></span><p class="line867">
<h3 id="A.2BW2ZOYIu.2Bi6FlcGNuW8aWxleLXpR1KA-">学习设计数据密集型应用</h3>
<span class="anchor" id="line-999"></span><span class="anchor" id="line-1000"></span><p class="line867">
<h1 id="A.2BW55OYGA7ftM-">实习总结</h1>
<span class="anchor" id="line-1001"></span><p class="line874">1. 学习tutor-playground 6 天 <span class="anchor" id="line-1002"></span>spring框架构建，采用标准的[三层架构] ， Thrift， Rpc， <a class="nonexistent" href="/RestApi">RestApi</a>， Mysql 存储， 单元测试， Redisson 实现缓存， 主要是数据一致性。 <span class="anchor" id="line-1003"></span><span class="anchor" id="line-1004"></span><p class="line862">2. 增加服务 <a class="nonexistent" href="/AmazeFeedback">AmazeFeedback</a> ， 建表， CRUD操作， Http Api   tutor-atm-user <span class="anchor" id="line-1005"></span><span class="anchor" id="line-1006"></span><p class="line874">3. 写Job 导出用户地址。 tutor-atm-address <span class="anchor" id="line-1007"></span><span class="anchor" id="line-1008"></span><p class="line874">4. 使用消息队列， 班课过期后，随材匹配自动变为暂停推单  tutor-atm-lesson <span class="anchor" id="line-1009"></span><span class="anchor" id="line-1010"></span><p class="line874">5. 更新tutor-at-lesson 线上数据  班课过期后，随材匹配自动变为暂停推单 tutor-atm-lesson <span class="anchor" id="line-1011"></span><span class="anchor" id="line-1012"></span><p class="line874">6. 服务端 - 导出运单列表增加『学生 id』 tutor-inventory-admin <span class="anchor" id="line-1013"></span><span class="anchor" id="line-1014"></span><p class="line874">7. 增加辅导老师带班建议      tutor-atm-user' <span class="anchor" id="line-1015"></span><span class="anchor" id="line-1016"></span><p class="line874">8. 服务端 - LessonVO 增加『剩余名额』 tutor-atm-lesson <span class="anchor" id="line-1017"></span><span class="anchor" id="line-1018"></span><p class="line874">9. 老师好评率数据计算  tutor-atm-user <span class="anchor" id="line-1019"></span><span class="anchor" id="line-1020"></span><p class="line874">10. 服务整理 use tutor-lesson instead of tutor-lesson-admin <span class="anchor" id="line-1021"></span><span class="anchor" id="line-1022"></span><p class="line874">11. 导出学生统计数据 成Excel Tutor-atm-stat <span class="anchor" id="line-1023"></span><span class="anchor" id="line-1024"></span><p class="line874">12. 服务端 - LessonVO 增加『首季用户占比』『首季用户续报率』『非首季用户续报率』 tutor-atm-lesson <span class="anchor" id="line-1025"></span><span class="anchor" id="line-1026"></span><p class="line874">13. 删除Http api tutor-episode-template/material  tutor-atm-lesson <span class="anchor" id="line-1027"></span><span class="anchor" id="line-1028"></span><p class="line874">14. 去掉tutor-mentor-admin 依赖 <span class="anchor" id="line-1029"></span><span class="anchor" id="line-1030"></span><p class="line874">15. 辅导老师身份问题修复  tutor-student-profile tutor-student-episode <span class="anchor" id="line-1031"></span><span class="anchor" id="line-1032"></span><p class="line874">16. 删除项目 tutor-lesson-admin <span class="anchor" id="line-1033"></span><span class="anchor" id="line-1034"></span><p class="line874">17. 修复导入金币Excel 错误  tutor-atm-episode <span class="anchor" id="line-1035"></span><span class="anchor" id="line-1036"></span><p class="line874">18. 整合ACL <span class="anchor" id="line-1037"></span><span class="anchor" id="line-1038"></span><p class="line862">19. 服务整理 <a class="nonexistent" href="/InventoryAdminProxy">InventoryAdminProxy</a> Rpc <span class="anchor" id="line-1039"></span><span class="anchor" id="line-1040"></span><p class="line874">20. inventory query 接口支持 name 模糊匹配 tutor-inventory-admin <span class="anchor" id="line-1041"></span><span class="anchor" id="line-1042"></span><p class="line874">21. tutor-stat 改用 tutor-student-product 提供的接口 <span class="anchor" id="line-1043"></span><span class="anchor" id="line-1044"></span><p class="line874">22. Team资源迁移 <span class="anchor" id="line-1045"></span><span class="anchor" id="line-1046"></span><p class="line874">23. atm-episode 线上导出讨论区日志（支持多个小班） <span class="anchor" id="line-1047"></span><span class="anchor" id="line-1048"></span><span class="anchor" id="bottom"></span></div>
<div id="pagebottom"></div>
</div>

