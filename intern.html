
<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><p class="line867">
<h1 id="A.2BW55OYGXli7A-">实习日记</h1>
<span class="anchor" id="line-2"></span><p class="line867"><strong>猿辅导-初高中服务器B端研发实习生-陈宽</strong> <span class="anchor" id="line-3"></span><span class="anchor" id="line-4"></span><p class="line867"><div class="table-of-contents"><p class="table-of-contents-heading">目录<ol><li>
<a href="#A.2BW55OYGXli7A-">实习日记</a><ol><li>
<a href="#play_ground_task_1">play ground task 1</a><ol><li>
<a href="#logic_.26.26_service">logic &amp;&amp; service</a></li><li>
<a href="#RPC_.26.26_REST">RPC &amp;&amp; REST</a></li></ol></li><li>
<a href="#May_30">May 30</a><ol><li>
<a href="#RestController">RestController</a></li><li>
<a href="#Mac_.2BUXOV7XrvU.2BM-">Mac 关闭端口</a></li><li>
<a href="#A.2BZXBjbg-VO_.2BdoRPf3UoVzpmbw-">数据VO 的使用场景</a></li><li>
<a href="#A.2BUXNOjg-Test">关于Test</a></li><li>
<a href="#Rest_.2BT391KInEgwM-">Rest 使用规范</a></li></ol></li><li>
<a href="#May_31">May 31</a><ol><li>
<a href="#DataNotFoundException">DataNotFoundException</a></li><li>
<a href="#A.2BWJ5SoFtXa7U-Optional">增加字段Optional</a></li><li>
<a href="#Mac_.2BU4ZT8lR9TuQ_.2BYwdO5A-">Mac 历史命令 指令</a></li></ol></li><li>
<a href="#June_4">June 4</a><ol><li>
<a href="#Query_.2BdoROJHnNZblfDw-">Query 的两种方式</a></li></ol></li><li>
<a href="#June_5">June 5</a><ol><li>
<a href="#A.2BW4lRaIO3U9Y-userId.2Be0llcGNu-">安全获取userId等数据</a></li><li>
<a href="#online.2BUgZlLw_.2BVAhedmTNT1w-">online分支 合并操作</a></li><li>
<a href="#DB_.2BZS9jAZicZYdbVw-">DB 支持颜文字</a></li><li>
<a href="#A.2BmHl27pDof3JtQXoL-">项目部署流程</a></li></ol></li><li>
<a href="#June_06">June 06</a><ol><li>
<a href="#A.2BenpQPHaEUiRlrVSMj9RW3g-">空值的判断和返回</a></li><li>
<a href="#A.2BenpQPFIkZa0-">空值判断</a></li><li>
<a href="#A.2Bj9RW3np6UDw-">返回空值</a></li></ol></li><li>
<a href="#June_09">June 09</a><ol><li>
<a href="#A.2BW.2FxR.2Bg-CSV">导出CSV</a></li></ol></li><li>
<a href="#June_10">June 10</a></li><li>
<a href="#June_11">June 11</a><ol><li>
<a href="#A.2BW.2FxlcFJnj8d6Cw-">导数剧过程</a></li></ol></li><li>
<a href="#June_12">June 12</a></li><li>
<a href="#June_13">June 13</a><ol><li>
<a href="#git_.2BW2ZOYA-">git 学习</a></li><li>
<a href="#git_merge">git merge</a></li><li>
<a href="#git_rebase">git rebase</a></li><li>
<a href="#git_reset">git reset</a></li></ol></li><li>
<a href="#June_14">June 14</a><ol><li>
<a href="#jsonCreater">jsonCreater</a></li></ol></li><li>
<a href="#June_16">June 16</a><ol><li>
<a href="#A.2BfxNbWGVwY25ek04AgfRgJ5XumJg_callback.2BieNRsw-">缓存数据库一致性问题 callback解决</a></li></ol></li><li>
<a href="#June_19">June 19</a><ol><li>
<a href="#Episode">Episode</a></li></ol></li><li>
<a href="#June_20">June 20</a><ol><li>
<a href="#Charles">Charles</a></li></ol></li><li>
<a href="#June_21">June 21</a><ol><li>
<a href="#A.2BZyxXMHOvWINeOHUoU8JlcJFNf24-">本地环境常用参数配置</a></li><li>
<a href="#Git_Cherry_Pick_.2BZM1PXA-">Git Cherry Pick 操作</a></li><li>
<a href="#A.2BUiR6eg_.2BVIw_.2BUgZrtYv7U9Y-">判空 和 分段读取</a></li></ol></li><li>
<a href="#June_22">June 22</a></li><li>
<a href="#June_25">June 25</a></li><li>
<a href="#June_26">June 26</a></li><li>
<a href="#June_27">June 27</a><ol><li>
<a href="#A.2BW2ZOYG4FdAZnDVKh-">学习清理服务</a></li></ol></li><li>
<a href="#June_28_.26_29">June 28 &amp; 29</a><ol><li>
<a href="#A.2BfSJfFQ_ES">索引 ES</a></li></ol></li><li>
<a href="#July_2">July 2</a><ol><li>
<a href="#cache_key">cache key</a></li></ol></li><li>
<a href="#July_3">July 3</a></li><li>
<a href="#July_4">July 4</a></li><li>
<a href="#July_5">July 5</a></li><li>
<a href="#July_6">July 6</a></li><li>
<a href="#July_9_.26.26_July_10">July 9 &amp;&amp; July 10</a></li><li>
<a href="#July_11">July 11</a></li><li>
<a href="#July_12">July 12</a><ol><li>
<a href="#git_reset_.2BTgl5zQ-">git reset 三种</a></li><li>
<a href="#A.2BZbByW1tmTmA---Git.2B.2Fww-MVN.2B.2Fww-shell">新牛学习--Git，MVN，shell</a></li></ol></li><li>
<a href="#July_13">July 13</a></li><li>
<a href="#July_14">July 14</a></li><li>
<a href="#July_15">July 15</a><ol><li>
<a href="#A.2BZbByWw---Java">新牛--Java</a></li></ol></li><li>
<a href="#July_17">July 17</a><ol><li>
<a href="#git_.2BT.2B5lOU5LUk1j0E6kj8d2hFGFW7k-">git 修改之前提交过的内容</a></li><li>
<a href="#shell">shell</a></li></ol></li><li>
<a href="#July_18">July 18</a><ol><li>
<a href="#Test_.2BXA9XUQ-">Test 小坑</a></li></ol></li><li>
<a href="#July_19">July 19</a><ol><li>
<a href="#A.2BZbByW1tmTmA---JVM_.2BbfFRZU6GieM-">新牛学习--JVM 深入了解</a></li></ol></li><li>
<a href="#July_20">July 20</a><ol><li>
<a href="#A.2BlsZPU1tmTmA_JVM.2BjANPGA-">集体学习 JVM调优</a></li></ol></li><li>
<a href="#July_21-26">July 21-26</a><ol><li>
<a href="#Redis_.2BThpSoVtmTmA-">Redis 业务学习</a></li><li>
<a href="#New-Bull_.2BXnZT0X8Wegt1MW1FUWVt8Q-">New-Bull 并发编程由浅入深</a></li><li>
<a href="#A.2Bfud.2B7Q-Tutor-team_.2BThpSoWV0dAY-">继续Tutor-team 业务整理</a></li></ol></li><li>
<a href="#July_29">July 29</a><ol><li>
<a href="#A.2BTgNZKU4Di.2B2KAA-">七天七语言</a></li></ol></li><li>
<a href="#July_31">July 31</a><ol><li>
<a href="#A.2BZw1SoWV0dAY-">服务整理</a></li></ol></li><li>
<a href="#Aug_1">Aug 1</a><ol><li>
<a href="#A.2BW2ZOYA-redis.2BdvhRc3UobNU-">学习redis相关用法</a></li></ol></li><li>
<a href="#Aug_2">Aug 2</a><ol><li>
<a href="#A.2BZbByW1tmTmA_--_.2Bi76LoWVwY25bxpbGV4telHUo-">新牛学习 -- 设计数据密集型应用</a></li><li>
<a href="#A.2Bfud.2B7Q-tutor-team.2BZw1SoWV0dAb.2FDGXgV1E-">继续tutor-team服务整理，无坑</a></li></ol></li><li>
<a href="#Aug_3">Aug 3</a><ol><li>
<a href="#A.2BW.2FxR.2Bouoi7pTOmXlX9c-">导出讨论区日志</a></li><li>
<a href="#A.2BeyxOAGshdTOL9w-redis">第一次申请redis</a></li></ol></li><li>
<a href="#Aug_4">Aug 4</a><ol><li>
<a href="#A.2BW2ZOYIu.2Bi6FlcGNuW8aWxleLXpR1KA-">学习设计数据密集型应用</a></li></ol></li></ol></li><li>
<a href="#A.2BW55OYGA7ftM-">实习总结</a></li></ol></div> <span class="anchor" id="line-5"></span><span class="anchor" id="line-6"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-7"></span>
<h2 id="play_ground_task_1">play ground task 1</h2>
<span class="anchor" id="line-8"></span><p class="line867">
<h3 id="logic_.26.26_service">logic &amp;&amp; service</h3>
<span class="anchor" id="line-9"></span><p class="line874">* Logic层和Service层有什么区别？Logic 处理数据，调用service , Service 调用DAO <span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span><p class="line867">
<h3 id="RPC_.26.26_REST">RPC &amp;&amp; REST</h3>
<span class="anchor" id="line-12"></span><p class="line874">* Rpc接口和REST接口的用途有什么区别？是否可以统一？ <span class="anchor" id="line-13"></span><span class="anchor" id="line-14"></span><p class="line874">REST ： GET 获取数据/POST 更新or创建数据/ DELETE 删除数据 RPC 直接用thrift 框架/非常容易实现，然后再写一个RPCHandler 即可 <span class="anchor" id="line-15"></span><span class="anchor" id="line-16"></span><p class="line874">* Spring注解中，@Bean和@Component有什么区别？ <span class="anchor" id="line-17"></span><span class="anchor" id="line-18"></span><ul><li style="list-style-type:none">@Component以及他的特殊化(@Controller, @Service 和 @Repository)允许在通过类路径扫描自动发现。@Bean却只能在配置类中明确的声明一个单例的bean。 <span class="anchor" id="line-19"></span><span class="anchor" id="line-20"></span></li></ul><p class="line874">*哪些地方使用了Spring AOP？没有 <span class="anchor" id="line-21"></span><span class="anchor" id="line-22"></span><p class="line867"><hr class="hr1" /><p class="line874"> <span class="anchor" id="line-23"></span>目前还没有QaQ <span class="anchor" id="line-24"></span><span class="anchor" id="line-25"></span><p class="line874">*数据存储除了mysql，还有什么可能的方案？Key--Value的nosql？ <span class="anchor" id="line-26"></span><span class="anchor" id="line-27"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-28"></span>
<h2 id="May_30">May 30</h2>
<span class="anchor" id="line-29"></span><p class="line867">
<h3 id="RestController">RestController</h3>
<span class="anchor" id="line-30"></span><p class="line862">1. 注意@<a class="nonexistent" href="/RestController">RestController</a> 和@Controller的区分 <span class="anchor" id="line-31"></span><span class="anchor" id="line-32"></span><p class="line867">
<h3 id="Mac_.2BUXOV7XrvU.2BM-">Mac 关闭端口</h3>
<span class="anchor" id="line-33"></span><p class="line874">2. MAC 查找并关闭8080 端口 查找8080端口 <span class="anchor" id="line-34"></span><span class="anchor" id="line-35"></span><p class="line874">sudo lsof -i :8080 <span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span><p class="line874">然后根据PID杀进程： <span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><p class="line874">sudo kill -9 61342（即pid） <span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><p class="line867">
<h3 id="A.2BZXBjbg-VO_.2BdoRPf3UoVzpmbw-">数据VO 的使用场景</h3>
<span class="anchor" id="line-42"></span><p class="line874">3. create 对象： logic 和controller 返回VO， service和db返回 id <span class="anchor" id="line-43"></span><span class="anchor" id="line-44"></span><p class="line867">
<h3 id="A.2BUXNOjg-Test">关于Test</h3>
<span class="anchor" id="line-45"></span><p class="line874">4. 测试尽量使用 assertthat <span class="anchor" id="line-46"></span><span class="anchor" id="line-47"></span><p class="line867">
<h3 id="Rest_.2BT391KInEgwM-">Rest 使用规范</h3>
<span class="anchor" id="line-48"></span><p class="line862">5. REST 规范：  <a class="http" href="http://wangwei.info/about-rest-api/">http://wangwei.info/about-rest-api/</a> <span class="anchor" id="line-49"></span><span class="anchor" id="line-50"></span><p class="line874">===== 单元测试 =====. <span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><ul><li style="list-style-type:none">@Spy <span class="anchor" id="line-53"></span><p class="line862">private <a class="nonexistent" href="/NamedParameterJdbcTemplate">NamedParameterJdbcTemplate</a> dbwriter = <a class="nonexistent" href="/TestDbHelper">TestDbHelper</a>.createNamedParameterJdbcTemplateInMemory(); @<a class="nonexistent" href="/InjectMocks">InjectMocks</a> private <a class="nonexistent" href="/DbTodoItemStorageImpl">DbTodoItemStorageImpl</a> todoItemStorage = new <a class="nonexistent" href="/DbTodoItemStorageImpl">DbTodoItemStorageImpl</a>(); <span class="anchor" id="line-54"></span><span class="anchor" id="line-55"></span></li></ul><p class="line874">注意sql名称和规范 <span class="anchor" id="line-56"></span><span class="anchor" id="line-57"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-58"></span>
<h2 id="May_31">May 31</h2>
<span class="anchor" id="line-59"></span><p class="line867">
<h3 id="DataNotFoundException">DataNotFoundException</h3>
<span class="anchor" id="line-60"></span><p class="line874">1. complete tutor-playground  RPC interface with thrift define. <span class="anchor" id="line-61"></span><span class="anchor" id="line-62"></span><p class="line862">when define the GET (by id) , need throw the <a class="nonexistent" href="/DataNotFound">DataNotFound</a> Exception every time! <span class="anchor" id="line-63"></span><span class="anchor" id="line-64"></span><p class="line867">
<h3 id="A.2BWJ5SoFtXa7U-Optional">增加字段Optional</h3>
<span class="anchor" id="line-65"></span><p class="line874">2. When add the new Attribute to the Object, in thrift , it should be optional! <span class="anchor" id="line-66"></span><span class="anchor" id="line-67"></span><p class="line867">
<h3 id="Mac_.2BU4ZT8lR9TuQ_.2BYwdO5A-">Mac 历史命令 指令</h3>
<span class="anchor" id="line-68"></span><p class="line862">3. tips :MAC查找历史命令～～～history |grep &lt;command&gt; <span class="anchor" id="line-69"></span><span class="anchor" id="line-70"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-71"></span>
<h2 id="June_4">June 4</h2>
<span class="anchor" id="line-72"></span><p class="line867">
<h3 id="Query_.2BdoROJHnNZblfDw-">Query 的两种方式</h3>
<span class="anchor" id="line-73"></span><p class="line874">spring sql query两种方式： 1. 用filter，在各个属性上建立filter（service层） 2. 使用条件condition判断，（db层） <span class="anchor" id="line-74"></span><span class="anchor" id="line-75"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-76"></span>
<h2 id="June_5">June 5</h2>
<span class="anchor" id="line-77"></span><p class="line867">
<h3 id="A.2BW4lRaIO3U9Y-userId.2Be0llcGNu-">安全获取userId等数据</h3>
<span class="anchor" id="line-78"></span><p class="line862">1. userId 需要从<a class="nonexistent" href="/SecHelper">SecHelper</a>中获取，防止他人伪造userId <span class="anchor" id="line-79"></span><span class="anchor" id="line-80"></span><p class="line867">
<h3 id="online.2BUgZlLw_.2BVAhedmTNT1w-">online分支 合并操作</h3>
<span class="anchor" id="line-81"></span><p class="line874">2. 合代码的git操作： <span class="anchor" id="line-82"></span><span class="anchor" id="line-83"></span><p class="line874">git checkout master <span class="anchor" id="line-84"></span><span class="anchor" id="line-85"></span><p class="line874">git pull <span class="anchor" id="line-86"></span><span class="anchor" id="line-87"></span><p class="line874">git checkout online <span class="anchor" id="line-88"></span><span class="anchor" id="line-89"></span><p class="line874">git pull <span class="anchor" id="line-90"></span><span class="anchor" id="line-91"></span><p class="line874">git merge origin/master --log --no-ff <span class="anchor" id="line-92"></span><span class="anchor" id="line-93"></span><p class="line874">git commit --amend <span class="anchor" id="line-94"></span><span class="anchor" id="line-95"></span><p class="line874">git push online-review <span class="anchor" id="line-96"></span><span class="anchor" id="line-97"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-98"></span>
<h3 id="DB_.2BZS9jAZicZYdbVw-">DB 支持颜文字</h3>
<span class="anchor" id="line-99"></span><p class="line874">3. Db支持U0001f60a颜文字等操作～～～： for example : tutorMentorApi.datasource.tomcat.initSQL: SET NAMES utf8mb4  (yaml) <span class="anchor" id="line-100"></span><span class="anchor" id="line-101"></span><p class="line862">CREATE TABLE <tt class="backtick">amaze_feedback</tt> ( <span class="anchor" id="line-102"></span><span class="anchor" id="line-103"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">userId</tt> int(11) unsigned NOT NULL, <span class="anchor" id="line-104"></span></li><li style="list-style-type:none"><p class="line891"><tt class="backtick">content</tt> text COLLATE utf8mb4_unicode_ci, <span class="anchor" id="line-105"></span></li><li style="list-style-type:none"><p class="line891"><tt class="backtick">imageIds</tt> text CHARACTER SET utf8 NOT NULL, <span class="anchor" id="line-106"></span></li><li style="list-style-type:none"><p class="line891"><tt class="backtick">createdTime</tt> bigint(20) NOT NULL, PRIMARY KEY (<tt class="backtick">id</tt>) <span class="anchor" id="line-107"></span><span class="anchor" id="line-108"></span></li></ul><p class="line874">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; <span class="anchor" id="line-109"></span><span class="anchor" id="line-110"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-111"></span>
<h3 id="A.2BmHl27pDof3JtQXoL-">项目部署流程</h3>
<span class="anchor" id="line-112"></span><p class="line862">4.项目部署基本流程: 参考wiki dev/deploy <a class="https" href="https://wiki.zhenguanyu.com/Dev/Deploy">https://wiki.zhenguanyu.com/Dev/Deploy</a> <span class="anchor" id="line-113"></span><span class="anchor" id="line-114"></span><p class="line874">观察上线状态，注意主机是否重启成功。stage机器上完后，登陆跳板机（ssh liht01@access1）, 以用户名tutor登陆到到相应的主机，查看／home／shared／log/下面的log文件，验证服务的状态。如果一切正常，点击"继续"来完成剩余机器的上线。 <span class="anchor" id="line-115"></span><span class="anchor" id="line-116"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-117"></span>
<h2 id="June_06">June 06</h2>
<span class="anchor" id="line-118"></span><p class="line867">
<h3 id="A.2BenpQPHaEUiRlrVSMj9RW3g-">空值的判断和返回</h3>
<span class="anchor" id="line-119"></span><p class="line874">1. 用前闭后开的区间来表示一个时间 Range <span class="anchor" id="line-120"></span><span class="anchor" id="line-121"></span><p class="line867">
<h3 id="A.2BenpQPFIkZa0-">空值判断</h3>
<span class="anchor" id="line-122"></span><p class="line862">2. String.isBlank(str); String.isNotBlank(str); <a class="nonexistent" href="/ArrayUtils">ArrayUtils</a>.isEmpty(arr); <a class="nonexistent" href="/ArrayUtils">ArrayUtils</a>.isNotEmpty(arr); <a class="nonexistent" href="/CollectionUtils">CollectionUtils</a>.isEmpty(coll); <span class="anchor" id="line-123"></span><span class="anchor" id="line-124"></span><p class="line867">
<h3 id="A.2Bj9RW3np6UDw-">返回空值</h3>
<span class="anchor" id="line-125"></span><p class="line862">3. Collections.emptyMap(); Collections.emptyList(); Collections.emptySet(); <a class="nonexistent" href="/StringUtils">StringUtils</a>.EMPTY; <span class="anchor" id="line-126"></span><span class="anchor" id="line-127"></span><p class="line862">-- JMS ：<a class="http" href="http://www.cnblogs.com/chenpi/p/5559349.html">http://www.cnblogs.com/chenpi/p/5559349.html</a> <span class="anchor" id="line-128"></span><span class="anchor" id="line-129"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-130"></span>
<h2 id="June_09">June 09</h2>
<span class="anchor" id="line-131"></span><p class="line867">
<h3 id="A.2BW.2FxR.2Bg-CSV">导出CSV</h3>
<span class="anchor" id="line-132"></span><p class="line874">Get skill : Java save data into CSV file <span class="anchor" id="line-133"></span><span class="anchor" id="line-134"></span><p class="line874">详见 tutor-address <span class="anchor" id="line-135"></span><span class="anchor" id="line-136"></span><p class="line874">注意，job 的日志一定要详细，有开始和结束！ <span class="anchor" id="line-137"></span><span class="anchor" id="line-138"></span><p class="line874">job结束后，最好有一个validare job <span class="anchor" id="line-139"></span><span class="anchor" id="line-140"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-141"></span>
<h2 id="June_10">June 10</h2>
<span class="anchor" id="line-142"></span><p class="line874">参加公司TB～ U0001f604 <span class="anchor" id="line-143"></span><span class="anchor" id="line-144"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-145"></span>
<h2 id="June_11">June 11</h2>
<span class="anchor" id="line-146"></span><p class="line867">
<h3 id="A.2BW.2FxlcFJnj8d6Cw-">导数剧过程</h3>
<span class="anchor" id="line-147"></span><p class="line874">完成导出用户地址job, <span class="anchor" id="line-148"></span><span class="anchor" id="line-149"></span><p class="line874">要连接跳板机， 上传自己的jar包及相关文件 到自己的工作目录下面。此处可用软连接：ln -s 源文件 目标文件 <span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span><p class="line862">关于上传文件： <a class="https" href="https://wiki.zhenguanyu.com/DEVOP/SEC/Mupload">https://wiki.zhenguanyu.com/DEVOP/SEC/Mupload</a> 随后使用wget 获取。 <span class="anchor" id="line-152"></span><span class="anchor" id="line-153"></span><p class="line874">运行jar包： <span class="anchor" id="line-154"></span><span class="anchor" id="line-155"></span><p class="line862">nohup java -jar xxxxxx.jar --server.port=9399 --spring.profiles.active=online --logging.config=classpath:log4j2.yaml --captain.enabled=false --job.active=XXXXXXXXXXXXXJob --fix=true &gt; log/XXXXXXXXXXX.out <span class="anchor" id="line-156"></span><span class="anchor" id="line-157"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-158"></span>继续tutor-playground2， 测试了res接口， 对第一次提交的代码进行修改， 研究了redis的用法及配置。 <span class="anchor" id="line-159"></span><span class="anchor" id="line-160"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-161"></span><span class="anchor" id="line-162"></span><p class="line867">
<h2 id="June_12">June 12</h2>
<span class="anchor" id="line-163"></span><p class="line874">上线了tutor-atm-lesson <span class="anchor" id="line-164"></span><span class="anchor" id="line-165"></span><p class="line874">更新数据时，LOG日志应该更详细一些， 第一次上传的job 没有 “job end ”信息， 差评！！！！！！！！！！！！！！ <span class="anchor" id="line-166"></span><span class="anchor" id="line-167"></span><p class="line874">继续tutor-playground， 使用缓存时还是要好好考虑数据一致性的问题哈！ <span class="anchor" id="line-168"></span><span class="anchor" id="line-169"></span><p class="line874">git 返回到最新的提交～git reset --hard origin/master <span class="anchor" id="line-170"></span><span class="anchor" id="line-171"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-172"></span><span class="anchor" id="line-173"></span><p class="line867">
<h2 id="June_13">June 13</h2>
<span class="anchor" id="line-174"></span><p class="line867">
<h3 id="git_.2BW2ZOYA-">git 学习</h3>
<span class="anchor" id="line-175"></span><p class="line874">git pull = git fetch + git merge <span class="anchor" id="line-176"></span><span class="anchor" id="line-177"></span><p class="line874">git pull --rebase = git fetch + git rebase <span class="anchor" id="line-178"></span><span class="anchor" id="line-179"></span><p class="line874">现在来看看git merge和git rebase的区别。 <span class="anchor" id="line-180"></span><span class="anchor" id="line-181"></span><p class="line874">假设有3次提交A,B,C。 <span class="anchor" id="line-182"></span><span class="anchor" id="line-183"></span><p class="line867"><img alt="imageView2/2/w/332" class="external_image" src="https://upload-images.jianshu.io/upload_images/310893-b3f2c56508fce814.png?imageMogr2/auto-orient/strip" title="imageView2/2/w/332" /> 在远程分支origin的基础上创建一个名为"mywork"的分支并提交了，同时有其他人在"origin"上做了一些修改并提交了。 <span class="anchor" id="line-184"></span><span class="anchor" id="line-185"></span><p class="line867"><img alt="imageView2/2/w/385" class="external_image" src="https://upload-images.jianshu.io/upload_images/310893-5e808595be2a25a0.png?imageMogr2/auto-orient/strip" title="imageView2/2/w/385" /> 其实这个时候E不应该提交，因为提交后会发生冲突。如何解决这些冲突呢？有以下两种方法： <span class="anchor" id="line-186"></span><span class="anchor" id="line-187"></span><p class="line867">
<h3 id="git_merge">git merge</h3>
<span class="anchor" id="line-188"></span><p class="line874">用git pull命令把"origin"分支上的修改pull下来与本地提交合并（merge）成版本M，但这样会形成图中的菱形，让人很困惑。 <span class="anchor" id="line-189"></span><span class="anchor" id="line-190"></span><p class="line867"><img alt="imageView2/2/w/448" class="external_image" src="https://upload-images.jianshu.io/upload_images/310893-d7b78643df684328.png?imageMogr2/auto-orient/strip" title="imageView2/2/w/448" /> <span class="anchor" id="line-191"></span><span class="anchor" id="line-192"></span><p class="line867">
<h3 id="git_rebase">git rebase</h3>
<span class="anchor" id="line-193"></span><p class="line874">创建一个新的提交R，R的文件内容和上面M的一样，但我们将E提交废除，当它不存在（图中用虚线表示）保持提交曲线为直线，让大家易于理解。 <span class="anchor" id="line-194"></span><span class="anchor" id="line-195"></span><p class="line874">在rebase的过程中，有时也会有conflict，这时Git会停止rebase并让用户去解决冲突，解决完冲突后，用git add命令去更新这些内容，然后不用执行git-commit,直接执行git rebase --continue,这样git会继续apply余下的补丁。在任何时候，都可以用git rebase --abort参数来终止rebase的行动，并且mywork分支会回到rebase开始前的状态。 <span class="anchor" id="line-196"></span><span class="anchor" id="line-197"></span><p class="line867"><img alt="imageView2/2/w/441" class="external_image" src="https://upload-images.jianshu.io/upload_images/310893-d1a838cd827f79ab.png?imageMogr2/auto-orient/strip" title="imageView2/2/w/441" /> <span class="anchor" id="line-198"></span><span class="anchor" id="line-199"></span><p class="line867">
<h3 id="git_reset">git reset</h3>
<span class="anchor" id="line-200"></span><p class="line862">git reset HEAD<sup>  回退版本，一个</sup>表示一个版本，可以多个，另外也可以使用 git reset HEAD～n这种形式。 <span class="anchor" id="line-201"></span><span class="anchor" id="line-202"></span><p class="line862">git reset --hard HEAD~1 更多命令  <a class="https" href="https://www.yiibai.com/git/git_reset.html">https://www.yiibai.com/git/git_reset.html</a>    hard 会删除上次提交之后的东西， soft不会？ <span class="anchor" id="line-203"></span><span class="anchor" id="line-204"></span><p class="line874">假设你已经添加了一个文件进入索引，但是而后又不打算把这个文件提交，此时可以使用git reset把这个文件从索引中去除 <span class="anchor" id="line-205"></span><span class="anchor" id="line-206"></span><p class="line874">$ git reset -- frotz.c                      (1) <span class="anchor" id="line-207"></span><span class="anchor" id="line-208"></span><p class="line874">$ git commit -m "Commit files in index"     (2) <span class="anchor" id="line-209"></span><span class="anchor" id="line-210"></span><p class="line874">$ git add frotz.c <span class="anchor" id="line-211"></span><span class="anchor" id="line-212"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-213"></span><span class="anchor" id="line-214"></span><p class="line867">
<h2 id="June_14">June 14</h2>
<span class="anchor" id="line-215"></span><p class="line874">今天主要做了 mentorAdvice 的相关操作工作 <span class="anchor" id="line-216"></span><span class="anchor" id="line-217"></span><p class="line867">
<h3 id="jsonCreater">jsonCreater</h3>
<span class="anchor" id="line-218"></span><p class="line862">@<a class="nonexistent" href="/JsonCreator">JsonCreator</a> 的包要注意！！！ <span class="anchor" id="line-219"></span><span class="anchor" id="line-220"></span><p class="line862">import com.fasterxml.jackson.annotation.<a class="nonexistent" href="/JsonCreator">JsonCreator</a>; <span class="anchor" id="line-221"></span><span class="anchor" id="line-222"></span><p class="line862">import com.fasterxml.jackson.annotation.<a class="nonexistent" href="/JsonValue">JsonValue</a>; <span class="anchor" id="line-223"></span><span class="anchor" id="line-224"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-225"></span><span class="anchor" id="line-226"></span><p class="line867">
<h2 id="June_16">June 16</h2>
<span class="anchor" id="line-227"></span><p class="line867">
<h3 id="A.2BfxNbWGVwY25ek04AgfRgJ5XumJg_callback.2BieNRsw-">缓存数据库一致性问题 callback解决</h3>
<span class="anchor" id="line-228"></span><p class="line874">主要看了redisson 和 db 操作，使用callback 解决数据不一致问题 <span class="anchor" id="line-229"></span><span class="anchor" id="line-230"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-231"></span><span class="anchor" id="line-232"></span><p class="line867">
<h2 id="June_19">June 19</h2>
<span class="anchor" id="line-233"></span><p class="line867">
<h3 id="Episode">Episode</h3>
<span class="anchor" id="line-234"></span><p class="line862">可参考： <a class="https" href="https://wiki.zhenguanyu.com/Livecast/MicroService/TutorEpisode#episode">https://wiki.zhenguanyu.com/Livecast/MicroService/TutorEpisode#episode</a> <span class="anchor" id="line-235"></span><span class="anchor" id="line-236"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-237"></span><span class="anchor" id="line-238"></span><p class="line867">
<h2 id="June_20">June 20</h2>
<span class="anchor" id="line-239"></span><p class="line874">熟悉了评价相关的业务。 <span class="anchor" id="line-240"></span><span class="anchor" id="line-241"></span><p class="line867">
<h3 id="Charles">Charles</h3>
<span class="anchor" id="line-242"></span><p class="line862">学会使用Charles 进行 mac 和 ios 端 请假捕获和抓包分析， 参考blog ： <a class="http" href="http://blog.devtang.com/2013/12/11/network-tool-charles-intr/">http://blog.devtang.com/2013/12/11/network-tool-charles-intr/</a> <span class="anchor" id="line-243"></span><span class="anchor" id="line-244"></span><p class="line874">遇到问题：需要Mac和iOS 安装相关证书，安装后，需要授权信任证书， 否则 网页或者app将无法打开。 <span class="anchor" id="line-245"></span><span class="anchor" id="line-246"></span><p class="line874">此外，网页端url 请求应该是统一处理过，无法查看， 但是app 端可以进行url查看 <span class="anchor" id="line-247"></span><span class="anchor" id="line-248"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-249"></span><span class="anchor" id="line-250"></span><p class="line867">
<h2 id="June_21">June 21</h2>
<span class="anchor" id="line-251"></span><p class="line867">
<h3 id="A.2BZyxXMHOvWINeOHUoU8JlcJFNf24-">本地环境常用参数配置</h3>
<span class="anchor" id="line-252"></span><p class="line874">--spring.profiles=test <span class="anchor" id="line-253"></span><span class="anchor" id="line-254"></span><p class="line874">--logging.config=classpath:log4j2.yaml <span class="anchor" id="line-255"></span><span class="anchor" id="line-256"></span><p class="line874">--rpcServer.port=5110 <span class="anchor" id="line-257"></span><span class="anchor" id="line-258"></span><p class="line874">--captain.restfulPort=6110 <span class="anchor" id="line-259"></span><span class="anchor" id="line-260"></span><p class="line874">--actuator.enabled=false <span class="anchor" id="line-261"></span><span class="anchor" id="line-262"></span><p class="line874">--logging.access.directory=/Users/chenkuan/Desktop/Yuanfudao <span class="anchor" id="line-263"></span><span class="anchor" id="line-264"></span><p class="line867">
<h3 id="Git_Cherry_Pick_.2BZM1PXA-">Git Cherry Pick 操作</h3>
<span class="anchor" id="line-265"></span><p class="line874">Master： <span class="anchor" id="line-266"></span><span class="anchor" id="line-267"></span><p class="line874">git ll 找到commit 记下 <span class="anchor" id="line-268"></span><span class="anchor" id="line-269"></span><p class="line874">git checkout online <span class="anchor" id="line-270"></span><span class="anchor" id="line-271"></span><p class="line874">git pull git cherry-pick a7099c3 <span class="anchor" id="line-272"></span><span class="anchor" id="line-273"></span><p class="line874">git commit --amend <span class="anchor" id="line-274"></span><span class="anchor" id="line-275"></span><p class="line867">
<h3 id="A.2BUiR6eg_.2BVIw_.2BUgZrtYv7U9Y-">判空 和 分段读取</h3>
<span class="anchor" id="line-276"></span><p class="line874">习惯性的对集合判空 <span class="anchor" id="line-277"></span><span class="anchor" id="line-278"></span><p class="line874">--- <span class="anchor" id="line-279"></span><span class="anchor" id="line-280"></span><p class="line862">@<a class="nonexistent" href="/ActuatorAnalysis">ActuatorAnalysis</a> <span class="anchor" id="line-281"></span><span class="anchor" id="line-282"></span><p class="line874">使用RPC时尽量分段读取 <span class="anchor" id="line-283"></span><span class="anchor" id="line-284"></span><p class="line862">Tip <a class="nonexistent" href="/MapUtilsEx">MapUtilsEx</a>.convertValue <span class="anchor" id="line-285"></span><span class="anchor" id="line-286"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-287"></span><span class="anchor" id="line-288"></span><p class="line867">
<h2 id="June_22">June 22</h2>
<span class="anchor" id="line-289"></span><p class="line874">今天写业务 <span class="anchor" id="line-290"></span><span class="anchor" id="line-291"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-292"></span><span class="anchor" id="line-293"></span><p class="line867">
<h2 id="June_25">June 25</h2>
<span class="anchor" id="line-294"></span><p class="line874">业务 <span class="anchor" id="line-295"></span><span class="anchor" id="line-296"></span><p class="line867">
<h2 id="June_26">June 26</h2>
<span class="anchor" id="line-297"></span><p class="line874">导出数据时，尽量分段导出。 <span class="anchor" id="line-298"></span><span class="anchor" id="line-299"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-300"></span><span class="anchor" id="line-301"></span><p class="line867">
<h2 id="June_27">June 27</h2>
<span class="anchor" id="line-302"></span><p class="line867">
<h3 id="A.2BW2ZOYG4FdAZnDVKh-">学习清理服务</h3>
<span class="anchor" id="line-303"></span><p class="line862">学习了如何了进行服务清理： 检查服务依赖，查看日志文件&gt;&gt;&gt;&gt;删除代码&gt;&gt;&gt;&gt;修改nginx&gt;&gt;&gt;&gt;删除服务实例 参考连接： <a class="https" href="https://wiki.zhenguanyu.com/Livecast/B/ServiceClean">https://wiki.zhenguanyu.com/Livecast/B/ServiceClean</a> <span class="anchor" id="line-304"></span><span class="anchor" id="line-305"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-306"></span><span class="anchor" id="line-307"></span><p class="line867">
<h2 id="June_28_.26_29">June 28 &amp; 29</h2>
<span class="anchor" id="line-308"></span><p class="line874">进行服务清理，好像没遇到坑 <span class="anchor" id="line-309"></span>
<h3 id="A.2BfSJfFQ_ES">索引 ES</h3>
<span class="anchor" id="line-310"></span><p class="line867"><a class="http" href="http://www.baeldung.com/lucene">http://www.baeldung.com/lucene</a>   <span class="anchor" id="line-311"></span><span class="anchor" id="line-312"></span><p class="line867"><a class="https" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html</a>  <span class="anchor" id="line-313"></span><span class="anchor" id="line-314"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-315"></span><span class="anchor" id="line-316"></span><p class="line867">
<h2 id="July_2">July 2</h2>
<span class="anchor" id="line-317"></span><p class="line867">
<h3 id="cache_key">cache key</h3>
<span class="anchor" id="line-318"></span><p class="line874">使用的时候注意，不要忘记id !!!!!!!!! 今天是一个惨痛的教训 <span class="anchor" id="line-319"></span><span class="anchor" id="line-320"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-321"></span><span class="anchor" id="line-322"></span><p class="line867">
<h2 id="July_3">July 3</h2>
<span class="anchor" id="line-323"></span><p class="line874">service 上线时候记得刷新， <span class="anchor" id="line-324"></span><span class="anchor" id="line-325"></span><p class="line862">另外又学会了 git revert---&gt;git commit --amend ---&gt;git push <span class="anchor" id="line-326"></span><span class="anchor" id="line-327"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-328"></span><span class="anchor" id="line-329"></span><p class="line867">
<h2 id="July_4">July 4</h2>
<span class="anchor" id="line-330"></span><p class="line862">Tips： 自动引入Jar包时也要看看版本，某些低版本功能可能不完善，比如 <a class="nonexistent" href="/StringUtils">StringUtils</a>.isNumberic 不同版本就有不一样的处理 <span class="anchor" id="line-331"></span><span class="anchor" id="line-332"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-333"></span><span class="anchor" id="line-334"></span><p class="line867">
<h2 id="July_5">July 5</h2>
<span class="anchor" id="line-335"></span><p class="line874">今天第一次发布Maven 包 <span class="anchor" id="line-336"></span><span class="anchor" id="line-337"></span><p class="line874">maven clean deploy <span class="anchor" id="line-338"></span><span class="anchor" id="line-339"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-340"></span><span class="anchor" id="line-341"></span><p class="line867">
<h2 id="July_6">July 6</h2>
<span class="anchor" id="line-342"></span><p class="line862">今日有红牛，<a class="nonexistent" href="/JavaCpp">JavaCpp</a> 有点难。。。 <span class="anchor" id="line-343"></span><span class="anchor" id="line-344"></span><p class="line874">1. 预习新牛课程 <span class="anchor" id="line-345"></span><span class="anchor" id="line-346"></span><p class="line862">[Pro Git](<a class="https" href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a>) 前3章，尤其是第3章*分支* <span class="anchor" id="line-347"></span><span class="anchor" id="line-348"></span><p class="line867">
<h2 id="July_9_.26.26_July_10">July 9 &amp;&amp; July 10</h2>
<span class="anchor" id="line-349"></span><p class="line874">复习Git， 上线业务 <span class="anchor" id="line-350"></span><span class="anchor" id="line-351"></span><p class="line874">学习了 Maven 和 shell <span class="anchor" id="line-352"></span><span class="anchor" id="line-353"></span><p class="line867"><a class="https" href="https://www.jianshu.com/p/e1c8e5bfa45e">https://www.jianshu.com/p/e1c8e5bfa45e</a> <span class="anchor" id="line-354"></span><span class="anchor" id="line-355"></span><p class="line867"><a class="http" href="http://www.infoq.com/cn/minibooks/maven-in-action">http://www.infoq.com/cn/minibooks/maven-in-action</a> <span class="anchor" id="line-356"></span><span class="anchor" id="line-357"></span><p class="line874">对Maven 有了进一步的了解，以前只会用但没有详细了解过。 对shell也有了大致的了解，可以看懂代码了，有机会自己写个东西玩玩 <span class="anchor" id="line-358"></span><span class="anchor" id="line-359"></span><p class="line867">
<h2 id="July_11">July 11</h2>
<span class="anchor" id="line-360"></span><p class="line874">上午scrum 会， 下午完成了两个task， 顺便读了读 Java 8 实战 <span class="anchor" id="line-361"></span><span class="anchor" id="line-362"></span><p class="line867">
<h2 id="July_12">July 12</h2>
<span class="anchor" id="line-363"></span><p class="line867">
<h3 id="git_reset_.2BTgl5zQ-">git reset 三种</h3>
<span class="anchor" id="line-364"></span><p class="line867"><a class="https" href="https://www.cnblogs.com/kidsitcn/p/4513297.html">https://www.cnblogs.com/kidsitcn/p/4513297.html</a> <span class="anchor" id="line-365"></span><span class="anchor" id="line-366"></span><p class="line867">
<h3 id="A.2BZbByW1tmTmA---Git.2B.2Fww-MVN.2B.2Fww-shell">新牛学习--Git，MVN，shell</h3>
<span class="anchor" id="line-367"></span><p class="line867"><span class="anchor" id="line-368"></span><span class="anchor" id="line-369"></span><span class="anchor" id="line-370"></span><span class="anchor" id="line-371"></span><span class="anchor" id="line-372"></span><span class="anchor" id="line-373"></span><span class="anchor" id="line-374"></span><span class="anchor" id="line-375"></span><span class="anchor" id="line-376"></span><span class="anchor" id="line-377"></span><span class="anchor" id="line-378"></span><span class="anchor" id="line-379"></span><span class="anchor" id="line-380"></span><span class="anchor" id="line-381"></span><span class="anchor" id="line-382"></span><span class="anchor" id="line-383"></span><span class="anchor" id="line-384"></span><span class="anchor" id="line-385"></span><span class="anchor" id="line-386"></span><span class="anchor" id="line-387"></span><span class="anchor" id="line-388"></span><span class="anchor" id="line-389"></span><span class="anchor" id="line-390"></span><span class="anchor" id="line-391"></span><span class="anchor" id="line-392"></span><span class="anchor" id="line-393"></span><span class="anchor" id="line-394"></span><span class="anchor" id="line-395"></span><span class="anchor" id="line-396"></span><span class="anchor" id="line-397"></span><span class="anchor" id="line-398"></span><span class="anchor" id="line-399"></span><span class="anchor" id="line-400"></span><span class="anchor" id="line-401"></span><span class="anchor" id="line-402"></span><span class="anchor" id="line-403"></span><span class="anchor" id="line-404"></span><span class="anchor" id="line-405"></span><span class="anchor" id="line-406"></span><span class="anchor" id="line-407"></span><span class="anchor" id="line-408"></span><span class="anchor" id="line-409"></span><span class="anchor" id="line-410"></span><span class="anchor" id="line-411"></span><span class="anchor" id="line-412"></span><span class="anchor" id="line-413"></span><span class="anchor" id="line-414"></span><span class="anchor" id="line-415"></span><span class="anchor" id="line-416"></span><span class="anchor" id="line-417"></span><span class="anchor" id="line-418"></span><span class="anchor" id="line-419"></span><span class="anchor" id="line-420"></span><span class="anchor" id="line-421"></span><span class="anchor" id="line-422"></span><span class="anchor" id="line-423"></span><span class="anchor" id="line-424"></span><span class="anchor" id="line-425"></span><span class="anchor" id="line-426"></span><span class="anchor" id="line-427"></span><span class="anchor" id="line-428"></span><span class="anchor" id="line-429"></span><span class="anchor" id="line-430"></span><span class="anchor" id="line-431"></span><span class="anchor" id="line-432"></span><span class="anchor" id="line-433"></span><span class="anchor" id="line-434"></span><span class="anchor" id="line-435"></span><span class="anchor" id="line-436"></span><span class="anchor" id="line-437"></span><span class="anchor" id="line-438"></span><span class="anchor" id="line-439"></span><span class="anchor" id="line-440"></span><span class="anchor" id="line-441"></span><span class="anchor" id="line-442"></span><span class="anchor" id="line-443"></span><span class="anchor" id="line-444"></span><span class="anchor" id="line-445"></span><span class="anchor" id="line-446"></span><span class="anchor" id="line-447"></span><span class="anchor" id="line-448"></span><span class="anchor" id="line-449"></span><span class="anchor" id="line-450"></span><pre><span class="anchor" id="line-1"></span>* Git如何存储数据
<span class="anchor" id="line-2"></span>    * Snapshot vs Diff
<span class="anchor" id="line-3"></span>    
<span class="anchor" id="line-4"></span>    Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。
<span class="anchor" id="line-5"></span>    Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。
<span class="anchor" id="line-6"></span>    
<span class="anchor" id="line-7"></span>    * 如何存储目录？
<span class="anchor" id="line-8"></span>    * 如何保证数据完整性
<span class="anchor" id="line-9"></span>        
<span class="anchor" id="line-10"></span>     Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。
<span class="anchor" id="line-11"></span>     Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：
<span class="anchor" id="line-12"></span>     24b9da6552252987aa493b52f8696cd6d3b00373
<span class="anchor" id="line-13"></span>     Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。
<span class="anchor" id="line-14"></span>
<span class="anchor" id="line-15"></span>* 文件状态
<span class="anchor" id="line-16"></span>    * 三个区域
<span class="anchor" id="line-17"></span>        * 工作区 working directory
<span class="anchor" id="line-18"></span>        * 暂存区 staging area
<span class="anchor" id="line-19"></span>        * 仓库  repo
<span class="anchor" id="line-20"></span>    * git reset的不同类型
<span class="anchor" id="line-21"></span>    git 的三种状态 和 reset感觉灰常有意思，棒！ 主要是Hard（三个指针都移动）， Soft（暂存区和仓库移动） 和Mixed（仓库移动）
<span class="anchor" id="line-22"></span>---
<span class="anchor" id="line-23"></span>
<span class="anchor" id="line-24"></span>### Git Workflow
<span class="anchor" id="line-25"></span>* branch和commit的关系
<span class="anchor" id="line-26"></span>* 在gerrit上提交一个review，工作流程是怎么样的
<span class="anchor" id="line-27"></span>    * 如果把分支A提到了分支B，会发生什么
<span class="anchor" id="line-28"></span>* rebase和merge的机制和适用场景
<span class="anchor" id="line-29"></span>* github的工作流程*
<span class="anchor" id="line-30"></span>* 版本管理工具的变迁*
<span class="anchor" id="line-31"></span>
<span class="anchor" id="line-32"></span>---
<span class="anchor" id="line-33"></span>
<span class="anchor" id="line-34"></span>### Maven
<span class="anchor" id="line-35"></span>* [幻灯片](https://wiki.zhenguanyu.com/fankai?action=AttachFile&amp;do=view&amp;target=Maven%E7%AE%80%E4%BB%8B.pdf)
<span class="anchor" id="line-36"></span>* 作为项目的对象模型
<span class="anchor" id="line-37"></span>    * 坐标与版本
<span class="anchor" id="line-38"></span>    * SNAPSHOT版本的意义
<span class="anchor" id="line-39"></span>* Maven的生命周期(clean default site (default 为主))
<span class="anchor" id="line-40"></span>    * 每个生命周期是一组有序的阶段 validate-&gt;compile-&gt;test-&gt;package-&gt;verify-&gt;install-&gt;deploy
<span class="anchor" id="line-41"></span>    * 解释mvn clean package的意义
<span class="anchor" id="line-42"></span>* Maven依赖管理
<span class="anchor" id="line-43"></span>   * 仓库的概念   (中央仓库，公司仓库)
<span class="anchor" id="line-44"></span>    
<span class="anchor" id="line-45"></span>   * 依赖范围  
<span class="anchor" id="line-46"></span>    compile 默认，编译，测试，运行都需要
<span class="anchor" id="line-47"></span>    provided 只在编译和测试时需要
<span class="anchor" id="line-48"></span>    runtime 只在测试和运行的时候需要
<span class="anchor" id="line-49"></span>    test 只在测试时候需要
<span class="anchor" id="line-50"></span>
<span class="anchor" id="line-51"></span>    * 如何确定依赖的版本
<span class="anchor" id="line-52"></span>    1. 显示确定依赖版本 2 DependencyManageMent中定义的版本 3. 传递依赖路径中长度最短的版本 
<span class="anchor" id="line-53"></span>* Maven常用命令
<span class="anchor" id="line-54"></span>mvn dependency:list
<span class="anchor" id="line-55"></span>mvn dependency:tree
<span class="anchor" id="line-56"></span>mvn dependency:analyze
<span class="anchor" id="line-57"></span>---
<span class="anchor" id="line-58"></span>
<span class="anchor" id="line-59"></span>### Shell脚本
<span class="anchor" id="line-60"></span>* Shell基础
<span class="anchor" id="line-61"></span>    * 变量
<span class="anchor" id="line-62"></span>    * 运算符
<span class="anchor" id="line-63"></span>    * 控制流
<span class="anchor" id="line-64"></span>* Shell脚本的适用场景
<span class="anchor" id="line-65"></span>* Shell脚本如何实现后台运行、重定向、并发等功能
<span class="anchor" id="line-66"></span>* 常用文本处理工具
<span class="anchor" id="line-67"></span>
<span class="anchor" id="line-68"></span>---
<span class="anchor" id="line-69"></span>
<span class="anchor" id="line-70"></span>### UNIX 设计原则
<span class="anchor" id="line-71"></span>* Controlling complexity is the essence of computer programming.
<span class="anchor" id="line-72"></span>* Keep It Simple, Stupid!
<span class="anchor" id="line-73"></span>
<span class="anchor" id="line-74"></span>---
<span class="anchor" id="line-75"></span>
<span class="anchor" id="line-76"></span>### 代码规范
<span class="anchor" id="line-77"></span>* 代码规范的原则和意义
<span class="anchor" id="line-78"></span>    * Programs must be written for people to read, and only incidentally for machines to execute. - SICP
<span class="anchor" id="line-79"></span>    * 保持代码风格的一致性比起追求最好的风格更加重要
<span class="anchor" id="line-80"></span>    * 重构是保持代码质量的重要手段
<span class="anchor" id="line-81"></span>
<span class="anchor" id="line-82"></span>---</pre><span class="anchor" id="line-451"></span><span class="anchor" id="line-452"></span><span class="anchor" id="line-453"></span><p class="line867">
<h2 id="July_13">July 13</h2>
<span class="anchor" id="line-454"></span><p class="line874">tutor-team服务整理 <span class="anchor" id="line-455"></span><span class="anchor" id="line-456"></span><p class="line867">
<h2 id="July_14">July 14</h2>
<span class="anchor" id="line-457"></span><p class="line874">周末来公司看了下 java 8 实战， 1-4 章。 <span class="anchor" id="line-458"></span><span class="anchor" id="line-459"></span><p class="line862">行为参数化(传递代码)-&gt;匿名类-&gt;Lambda表达式-&gt;使用方法引用 <span class="anchor" id="line-460"></span><span class="anchor" id="line-461"></span><p class="line874">引入流的概念，stream 内部有些像流水线式工作 <span class="anchor" id="line-462"></span><span class="anchor" id="line-463"></span><p class="line867">
<h2 id="July_15">July 15</h2>
<span class="anchor" id="line-464"></span><p class="line867">
<h3 id="A.2BZbByWw---Java">新牛--Java</h3>
<span class="anchor" id="line-465"></span><span class="anchor" id="line-466"></span><p class="line867"><span class="anchor" id="line-467"></span><span class="anchor" id="line-468"></span><span class="anchor" id="line-469"></span><span class="anchor" id="line-470"></span><span class="anchor" id="line-471"></span><span class="anchor" id="line-472"></span><span class="anchor" id="line-473"></span><span class="anchor" id="line-474"></span><span class="anchor" id="line-475"></span><span class="anchor" id="line-476"></span><pre><span class="anchor" id="line-1-1"></span>## 学习目标
<span class="anchor" id="line-2-1"></span>* 掌握Java语言的常用特性，包括
<span class="anchor" id="line-3-1"></span>    * 异常处理机制
<span class="anchor" id="line-4-1"></span>    * 类型信息和反射机制
<span class="anchor" id="line-5-1"></span>    * 泛型的原理和使用
<span class="anchor" id="line-6-1"></span>    * 注解
<span class="anchor" id="line-7-1"></span>* 了解Java 8引入的新特性
<span class="anchor" id="line-8-1"></span>    * Lambda表达式
<span class="anchor" id="line-9-1"></span>    * Stream API</pre><span class="anchor" id="line-477"></span><span class="anchor" id="line-478"></span><p class="line867"><span class="anchor" id="line-479"></span><span class="anchor" id="line-480"></span><span class="anchor" id="line-481"></span><span class="anchor" id="line-482"></span><span class="anchor" id="line-483"></span><span class="anchor" id="line-484"></span><span class="anchor" id="line-485"></span><span class="anchor" id="line-486"></span><span class="anchor" id="line-487"></span><span class="anchor" id="line-488"></span><span class="anchor" id="line-489"></span><span class="anchor" id="line-490"></span><span class="anchor" id="line-491"></span><span class="anchor" id="line-492"></span><span class="anchor" id="line-493"></span><pre><span class="anchor" id="line-1-2"></span>## 异常
<span class="anchor" id="line-2-2"></span>* 异常 vs 错误码
<span class="anchor" id="line-3-2"></span>* Java异常的分类和层次
<span class="anchor" id="line-4-2"></span>* Checked Exception vs Unchecked Exception
<span class="anchor" id="line-5-2"></span>    * 各自有什么优缺点
<span class="anchor" id="line-6-2"></span>* 如何保证释放资源
<span class="anchor" id="line-7-2"></span>    * 如果在catch或者finally块里抛出异常会如何？
<span class="anchor" id="line-8-2"></span>    上一个异常会被吞掉
<span class="anchor" id="line-9-2"></span>    * 如果在构造函数中跑出异常会如何？
<span class="anchor" id="line-10-1"></span>    不要这么做，会=有可能会使程序无法执行，也会增加上层编程人员的开发难度
<span class="anchor" id="line-11-1"></span>    * try-with-resource *
<span class="anchor" id="line-12-1"></span>    会释放资源
<span class="anchor" id="line-13-1"></span>* 什么叫suppressed exception，如果保留
<span class="anchor" id="line-14-1"></span>* 永远不要吞异常！</pre><span class="anchor" id="line-494"></span><span class="anchor" id="line-495"></span><p class="line867"><span class="anchor" id="line-496"></span><span class="anchor" id="line-497"></span><span class="anchor" id="line-498"></span><span class="anchor" id="line-499"></span><span class="anchor" id="line-500"></span><span class="anchor" id="line-501"></span><span class="anchor" id="line-502"></span><span class="anchor" id="line-503"></span><span class="anchor" id="line-504"></span><span class="anchor" id="line-505"></span><span class="anchor" id="line-506"></span><span class="anchor" id="line-507"></span><span class="anchor" id="line-508"></span><pre><span class="anchor" id="line-1-3"></span>### 类型信息RTTI
<span class="anchor" id="line-2-3"></span>* 类型也是一个对象
<span class="anchor" id="line-3-3"></span>* 获取和使用获取类型信息
<span class="anchor" id="line-4-3"></span>    * 向下转型 downcast
<span class="anchor" id="line-5-3"></span>    * instanceof 操作符
<span class="anchor" id="line-6-3"></span>    * isInstance() 方法
<span class="anchor" id="line-7-3"></span>    * typeid and typeinfo in c++ *
<span class="anchor" id="line-8-3"></span>* 反射
<span class="anchor" id="line-9-3"></span>* 动态代理
<span class="anchor" id="line-10-2"></span>    * 什么是代理模式
<span class="anchor" id="line-11-2"></span>    * 动态代理的作用
<span class="anchor" id="line-12-2"></span>    AOP用到</pre><span class="anchor" id="line-509"></span><span class="anchor" id="line-510"></span><p class="line867"><span class="anchor" id="line-511"></span><span class="anchor" id="line-512"></span><span class="anchor" id="line-513"></span><span class="anchor" id="line-514"></span><span class="anchor" id="line-515"></span><span class="anchor" id="line-516"></span><span class="anchor" id="line-517"></span><span class="anchor" id="line-518"></span><span class="anchor" id="line-519"></span><span class="anchor" id="line-520"></span><span class="anchor" id="line-521"></span><span class="anchor" id="line-522"></span><span class="anchor" id="line-523"></span><span class="anchor" id="line-524"></span><span class="anchor" id="line-525"></span><span class="anchor" id="line-526"></span><span class="anchor" id="line-527"></span><span class="anchor" id="line-528"></span><span class="anchor" id="line-529"></span><span class="anchor" id="line-530"></span><span class="anchor" id="line-531"></span><span class="anchor" id="line-532"></span><span class="anchor" id="line-533"></span><span class="anchor" id="line-534"></span><pre><span class="anchor" id="line-1-4"></span>### 泛型
<span class="anchor" id="line-2-4"></span>* 泛型和继承
<span class="anchor" id="line-3-4"></span>    * 协变 covariance
<span class="anchor" id="line-4-4"></span>    * 逆变 contravariance
<span class="anchor" id="line-5-4"></span>    * 不变 invariance
<span class="anchor" id="line-6-4"></span>~~~
<span class="anchor" id="line-7-4"></span>if a Derived is a Base, then
<span class="anchor" id="line-8-4"></span>   a Collection&lt;Derived&gt; is a Collection&lt;Base&gt; ?
<span class="anchor" id="line-9-4"></span>or a Collection&lt;Base&gt; is a Collection&lt;Derived&gt; ?
<span class="anchor" id="line-10-3"></span>~~~
<span class="anchor" id="line-11-3"></span>
<span class="anchor" id="line-12-3"></span>* 泛型数组？
<span class="anchor" id="line-13-2"></span>集合是不变的，数组是协变的
<span class="anchor" id="line-14-2"></span>---
<span class="anchor" id="line-15-1"></span>
<span class="anchor" id="line-16-1"></span>### 泛型
<span class="anchor" id="line-17-1"></span>* 泛型和继承
<span class="anchor" id="line-18-1"></span>~~~
<span class="anchor" id="line-19-1"></span>List&lt;Object&gt; objs = new ArrayList&lt;Integer&gt;();
<span class="anchor" id="line-20-1"></span>objs.add(3);
<span class="anchor" id="line-21-1"></span>objs.add("hello");
<span class="anchor" id="line-22-1"></span>~~~</pre><span class="anchor" id="line-535"></span><p class="line867"><span class="anchor" id="line-536"></span><span class="anchor" id="line-537"></span><span class="anchor" id="line-538"></span><span class="anchor" id="line-539"></span><pre><span class="anchor" id="line-1-5"></span>### 注解
<span class="anchor" id="line-2-5"></span>* 注解如何发挥作用
<span class="anchor" id="line-3-5"></span>* 各个元注解的意义 *</pre><span class="anchor" id="line-540"></span><span class="anchor" id="line-541"></span><p class="line867"><span class="anchor" id="line-542"></span><span class="anchor" id="line-543"></span><span class="anchor" id="line-544"></span><span class="anchor" id="line-545"></span><span class="anchor" id="line-546"></span><span class="anchor" id="line-547"></span><span class="anchor" id="line-548"></span><span class="anchor" id="line-549"></span><pre><span class="anchor" id="line-1-6"></span>### Lambda表达式
<span class="anchor" id="line-2-6"></span>* 从匿名类到Lambda表达式
<span class="anchor" id="line-3-6"></span>    * 闭包
<span class="anchor" id="line-4-5"></span>    * 有什么区别？
<span class="anchor" id="line-5-5"></span>* 函数式接口
<span class="anchor" id="line-6-5"></span>    * 函数不是一等公民(first class)
<span class="anchor" id="line-7-5"></span>    * 常用接口</pre><span class="anchor" id="line-550"></span><p class="line867"><span class="anchor" id="line-551"></span><span class="anchor" id="line-552"></span><span class="anchor" id="line-553"></span><span class="anchor" id="line-554"></span><span class="anchor" id="line-555"></span><span class="anchor" id="line-556"></span><span class="anchor" id="line-557"></span><span class="anchor" id="line-558"></span><span class="anchor" id="line-559"></span><pre><span class="anchor" id="line-1-7"></span>### Stream基本操作#
<span class="anchor" id="line-2-7"></span>* 不修改数据源
<span class="anchor" id="line-3-7"></span>* 延迟操作 (lazy execution)
<span class="anchor" id="line-4-6"></span>* 副作用 (side effect)
<span class="anchor" id="line-5-6"></span>* 常用操作
<span class="anchor" id="line-6-6"></span>
<span class="anchor" id="line-7-6"></span>* Optional如何解决NPE
<span class="anchor" id="line-8-5"></span>* Optional链式操作</pre><span class="anchor" id="line-560"></span><span class="anchor" id="line-561"></span><p class="line867">
<h2 id="July_17">July 17</h2>
<span class="anchor" id="line-562"></span><p class="line867">
<h3 id="git_.2BT.2B5lOU5LUk1j0E6kj8d2hFGFW7k-">git 修改之前提交过的内容</h3>
<span class="anchor" id="line-563"></span><p class="line867"><span class="anchor" id="line-564"></span><span class="anchor" id="line-565"></span><span class="anchor" id="line-566"></span><span class="anchor" id="line-567"></span><span class="anchor" id="line-568"></span><span class="anchor" id="line-569"></span><span class="anchor" id="line-570"></span><span class="anchor" id="line-571"></span><span class="anchor" id="line-572"></span><pre><span class="anchor" id="line-1-8"></span>git log –oneline 查看head
<span class="anchor" id="line-2-8"></span>git rebase -i xxxxxxx回到想修改的提交之前
<span class="anchor" id="line-3-8"></span>选择进行edit  
<span class="anchor" id="line-4-7"></span>进行修改
<span class="anchor" id="line-5-7"></span>git add . 
<span class="anchor" id="line-6-7"></span>git commit –amend (依然使用原来的提交) 
<span class="anchor" id="line-7-7"></span>git rebase –continue
<span class="anchor" id="line-8-6"></span>结束</pre><span class="anchor" id="line-573"></span><span class="anchor" id="line-574"></span><p class="line867">
<h3 id="shell">shell</h3>
<span class="anchor" id="line-575"></span><p class="line867"><span class="anchor" id="line-576"></span><span class="anchor" id="line-577"></span><span class="anchor" id="line-578"></span><pre><span class="anchor" id="line-1-9"></span>grep 'duration=[0-9][0-9]' http-request.log | cut -f4 |sort |uniq -c|sort -nr &gt;result
<span class="anchor" id="line-2-9"></span>grep 'products/342' http-request.log | cut -f1 -d :|uniq -c  &gt;result1</pre><span class="anchor" id="line-579"></span><p class="line874">作业里学到的两个shell 命令 <span class="anchor" id="line-580"></span><span class="anchor" id="line-581"></span><p class="line867">
<h2 id="July_18">July 18</h2>
<span class="anchor" id="line-582"></span><p class="line867">
<h3 id="Test_.2BXA9XUQ-">Test 小坑</h3>
<span class="anchor" id="line-583"></span><p class="line874">注意不可以 Test method为private <span class="anchor" id="line-584"></span><span class="anchor" id="line-585"></span><p class="line867">
<h2 id="July_19">July 19</h2>
<span class="anchor" id="line-586"></span><p class="line867">
<h3 id="A.2BZbByW1tmTmA---JVM_.2BbfFRZU6GieM-">新牛学习--JVM 深入了解</h3>
<span class="anchor" id="line-587"></span><p class="line867"><span class="anchor" id="line-588"></span><span class="anchor" id="line-589"></span><span class="anchor" id="line-590"></span><span class="anchor" id="line-591"></span><span class="anchor" id="line-592"></span><span class="anchor" id="line-593"></span><pre><span class="anchor" id="line-1-10"></span>### JVM
<span class="anchor" id="line-2-10"></span>* VM的概念和作用
<span class="anchor" id="line-3-9"></span>* JVM vs Java
<span class="anchor" id="line-4-8"></span>* 其他VM
<span class="anchor" id="line-5-8"></span>---</pre><span class="anchor" id="line-594"></span><span class="anchor" id="line-595"></span><p class="line867"><span class="anchor" id="line-596"></span><span class="anchor" id="line-597"></span><span class="anchor" id="line-598"></span><span class="anchor" id="line-599"></span><span class="anchor" id="line-600"></span><span class="anchor" id="line-601"></span><span class="anchor" id="line-602"></span><span class="anchor" id="line-603"></span><span class="anchor" id="line-604"></span><span class="anchor" id="line-605"></span><span class="anchor" id="line-606"></span><span class="anchor" id="line-607"></span><span class="anchor" id="line-608"></span><span class="anchor" id="line-609"></span><span class="anchor" id="line-610"></span><span class="anchor" id="line-611"></span><span class="anchor" id="line-612"></span><span class="anchor" id="line-613"></span><span class="anchor" id="line-614"></span><span class="anchor" id="line-615"></span><span class="anchor" id="line-616"></span><span class="anchor" id="line-617"></span><span class="anchor" id="line-618"></span><span class="anchor" id="line-619"></span><span class="anchor" id="line-620"></span><span class="anchor" id="line-621"></span><span class="anchor" id="line-622"></span><span class="anchor" id="line-623"></span><span class="anchor" id="line-624"></span><span class="anchor" id="line-625"></span><span class="anchor" id="line-626"></span><pre><span class="anchor" id="line-1-11"></span>### 内存数据区域
<span class="anchor" id="line-2-11"></span>* 有哪些数据区域
<span class="anchor" id="line-3-10"></span>1. 程序计数器，在虚拟机概念模型里，字节码解释器工作时候就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支循环，跳转，异常处理，线程恢复等基础功能，都需要依赖这个计数器完成。 为了线程切换的能恢复到正确的执行位置，每条线程都需要又一个独立的程序计数器，在线程私有内存中。
<span class="anchor" id="line-4-9"></span>2. Java 虚拟机栈 ， 与程序计数器一样，这也是线程私有的，生命周期与线程相同，描述的是Java方法执行的内存模型，每个方法在执行的时候都会创建一个Stack Frame，栈桢存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行的过程，就对应了一个栈桢在虚拟机栈中从入栈到出栈的过程。
<span class="anchor" id="line-5-9"></span>3. 本地方法栈。 与虚拟机栈发挥的作用比较相似，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法，也就是字节码的服务，本地方法栈则为虚拟机使用的Native方法服务，有的虚拟机Sun HotSpot 会把这两个合二为一。
<span class="anchor" id="line-6-8"></span>4. Java 堆， 垃圾回收的主要区域，绝大部分对象都会分配到堆上。 堆中还可细分为新生代和老年代，Eden 区，From Survivor吗， To Survivor， 老年代。 线程共享的Java堆中还会分出多个线程私有的分配缓冲区域，TLAB。 映射在物理上可以不连续，只要逻辑上是连续的就行。
<span class="anchor" id="line-7-8"></span>5. 方法区， 与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。  有些人也把这里叫做永久代。无法满足分配时会出发OOM。
<span class="anchor" id="line-8-7"></span>方法区还有个叫做运行常量池的地方，存放编译期生成的各种字面量和符号引用。
<span class="anchor" id="line-9-5"></span>
<span class="anchor" id="line-10-4"></span>* 堆和栈
<span class="anchor" id="line-11-4"></span>* 直接内存/Direct Memory
<span class="anchor" id="line-12-4"></span>
<span class="anchor" id="line-13-3"></span>直接内存： 不是Java虚拟机运行时的数据区域，但是也被频发使用，也可能导致OOM。 和NIO关联密切，Channel 与缓冲区，的IO方式，可以使Native函数库直接操作分配堆外内存，通过一个存储在Java堆中的DirectByBuffer 对象作为这块内存的引用，避免来回复制数据，显著提高性能。
<span class="anchor" id="line-14-3"></span>
<span class="anchor" id="line-15-2"></span>* 对象创建过程
<span class="anchor" id="line-16-2"></span>    * 新建对象的方式
<span class="anchor" id="line-17-2"></span>    先去常量池检查这个符号引用代表的类是不是已经被加载，解析和初始化过。 如果没有先执行相应的类加载过程
<span class="anchor" id="line-18-2"></span>    类加载检查通过后，虚拟机为对象进行分配内存，这里有“指针碰撞” 和 “空闲链表两种方法” 分别对应Java GC 的不同垃圾回收机制 ，compact 和 sweep    
<span class="anchor" id="line-19-2"></span>    分配完后，对对象进行必要的设置，例如是哪个类的实例， 对象的Hash, 对象的GC分代年龄信息。
<span class="anchor" id="line-20-2"></span>    这些做完之后，从Java程序员的角度 新建才刚刚开始，所有字段还都是零。 随后进行初始化。
<span class="anchor" id="line-21-2"></span>    
<span class="anchor" id="line-22-2"></span>* 如何处理并发？
<span class="anchor" id="line-23-1"></span>     1. 使用CAS 平分配方式，保证更新操作。
<span class="anchor" id="line-24-1"></span>     2. 另一种是把内存分配的动作， 按照线程划分在不同的区域，TLAB。
<span class="anchor" id="line-25-1"></span>
<span class="anchor" id="line-26-1"></span>* 对象内存布局
<span class="anchor" id="line-27-1"></span>    * 对象头 header
<span class="anchor" id="line-28-1"></span>        * Mark Word和类型指针    （对象Hash 码， 对象分代年龄 锁记录指针，重量级锁指针）
<span class="anchor" id="line-29-1"></span>    * 实例数据 instance data 真正存储的信息，各个定义的字段
<span class="anchor" id="line-30-1"></span>    * 对齐填充 padding  8字节整数倍</pre><span class="anchor" id="line-627"></span><span class="anchor" id="line-628"></span><p class="line867"><span class="anchor" id="line-629"></span><span class="anchor" id="line-630"></span><span class="anchor" id="line-631"></span><span class="anchor" id="line-632"></span><span class="anchor" id="line-633"></span><span class="anchor" id="line-634"></span><span class="anchor" id="line-635"></span><span class="anchor" id="line-636"></span><span class="anchor" id="line-637"></span><span class="anchor" id="line-638"></span><span class="anchor" id="line-639"></span><span class="anchor" id="line-640"></span><span class="anchor" id="line-641"></span><span class="anchor" id="line-642"></span><span class="anchor" id="line-643"></span><span class="anchor" id="line-644"></span><span class="anchor" id="line-645"></span><span class="anchor" id="line-646"></span><span class="anchor" id="line-647"></span><span class="anchor" id="line-648"></span><span class="anchor" id="line-649"></span><span class="anchor" id="line-650"></span><span class="anchor" id="line-651"></span><span class="anchor" id="line-652"></span><span class="anchor" id="line-653"></span><span class="anchor" id="line-654"></span><span class="anchor" id="line-655"></span><span class="anchor" id="line-656"></span><span class="anchor" id="line-657"></span><span class="anchor" id="line-658"></span><pre><span class="anchor" id="line-1-12"></span>### 垃圾收集
<span class="anchor" id="line-2-12"></span>* 概念和作用
<span class="anchor" id="line-3-11"></span>* 引用计数算法
<span class="anchor" id="line-4-10"></span>* 可达性分析算法
<span class="anchor" id="line-5-10"></span>    * GC Roots
<span class="anchor" id="line-6-9"></span>    1. 虚拟机栈中引用的对象
<span class="anchor" id="line-7-9"></span>    2 方法区中，类静态属性引用的对象
<span class="anchor" id="line-8-8"></span>    3 方法区中， 常量引用的对象
<span class="anchor" id="line-9-6"></span>    4 本地方法栈中JNI引用的对象
<span class="anchor" id="line-10-5"></span>
<span class="anchor" id="line-11-5"></span>    * 引用类型
<span class="anchor" id="line-12-5"></span>    强引用， 引用在就永远不会被回收
<span class="anchor" id="line-13-4"></span>    软引用，在系统即将要发生内存溢出异常之前，会把这些对象列进回收范围中进行二次回收
<span class="anchor" id="line-14-4"></span>    弱引用， 关联的对象只能生存到下一次垃圾收集之前，垃圾回收的时候，无论当前内存是否足够，都会回收掉只被弱引用关联的对象
<span class="anchor" id="line-15-3"></span>    虚引用， 无法通过虚引用获取对象实例，唯一目的就是对象回收时候会获得一个通知。
<span class="anchor" id="line-16-3"></span>
<span class="anchor" id="line-17-3"></span>    * 方法区需要回收吗？
<span class="anchor" id="line-18-3"></span>    需要， 废弃的常量和无用的类，（没有实例， 加载该类的ClassLoader已经回收，无法在任何位置通过反射访问该类的方法）
<span class="anchor" id="line-19-3"></span>
<span class="anchor" id="line-20-3"></span>* 常用收集算法
<span class="anchor" id="line-21-3"></span>    * 标记-清除 Mark-Sweep
<span class="anchor" id="line-22-3"></span>    * 复制算法
<span class="anchor" id="line-23-2"></span>    * 标记-整理 Mark-Compact
<span class="anchor" id="line-24-2"></span>    * 分代收集
<span class="anchor" id="line-25-2"></span>        * 新生代和老年代
<span class="anchor" id="line-26-2"></span>        * 永久代(Permanent Generation)和Metaspace
<span class="anchor" id="line-27-2"></span>* 安全点和安全区域 
<span class="anchor" id="line-28-2"></span>
<span class="anchor" id="line-29-2"></span>安全区域解决线程sleep blocked无法中断的问题，提供一块区域，到安全区挂起。</pre><span class="anchor" id="line-659"></span><p class="line867"><span class="anchor" id="line-660"></span><span class="anchor" id="line-661"></span><span class="anchor" id="line-662"></span><span class="anchor" id="line-663"></span><span class="anchor" id="line-664"></span><span class="anchor" id="line-665"></span><span class="anchor" id="line-666"></span><span class="anchor" id="line-667"></span><span class="anchor" id="line-668"></span><span class="anchor" id="line-669"></span><span class="anchor" id="line-670"></span><span class="anchor" id="line-671"></span><span class="anchor" id="line-672"></span><span class="anchor" id="line-673"></span><span class="anchor" id="line-674"></span><span class="anchor" id="line-675"></span><span class="anchor" id="line-676"></span><span class="anchor" id="line-677"></span><span class="anchor" id="line-678"></span><span class="anchor" id="line-679"></span><span class="anchor" id="line-680"></span><span class="anchor" id="line-681"></span><span class="anchor" id="line-682"></span><span class="anchor" id="line-683"></span><span class="anchor" id="line-684"></span><span class="anchor" id="line-685"></span><span class="anchor" id="line-686"></span><span class="anchor" id="line-687"></span><pre><span class="anchor" id="line-1-13"></span>### 垃圾收集器
<span class="anchor" id="line-2-13"></span>* 常用收集器
<span class="anchor" id="line-3-12"></span>    * Serial  
<span class="anchor" id="line-4-11"></span>    Stop the world 关掉所有线程，
<span class="anchor" id="line-5-11"></span>    优点，1. 简单高效，适合单核处理器，2 。 没有线程交互开销
<span class="anchor" id="line-6-10"></span>    
<span class="anchor" id="line-7-10"></span>   * Serial Old 
<span class="anchor" id="line-8-9"></span>   * ParNew
<span class="anchor" id="line-9-7"></span>    ParNew /SERIAL OLD 模型
<span class="anchor" id="line-10-6"></span>
<span class="anchor" id="line-11-6"></span>    * Parallel Scavenge  侧重于吞吐量 ，控制最大垃圾收集停顿时间-XX:MaxGCPauseMillis 直接设置吞吐量大小 -XX:GCTImeRatio
<span class="anchor" id="line-12-6"></span>     新生代收集器
<span class="anchor" id="line-13-5"></span>     
<span class="anchor" id="line-14-5"></span>   *Parallel Old
<span class="anchor" id="line-15-4"></span>    Parallel Old Parallel Scavenge 的老年版本
<span class="anchor" id="line-16-4"></span>    
<span class="anchor" id="line-17-4"></span>    * CMS
<span class="anchor" id="line-18-4"></span>    目标：获取最短停顿时间
<span class="anchor" id="line-19-4"></span>    初始标记（标记GC直接关联的对象），并发标记（进行GC root tracing），重新标记（标记期间，用户程序继续运行的改动）， 前两个阶段仍然是stop the world 
<span class="anchor" id="line-20-4"></span>    缺点： 对CPU资源要求敏感，无法处理浮动垃圾（运行时产生的垃圾），采用标记清除会产生碎片
<span class="anchor" id="line-21-4"></span>
<span class="anchor" id="line-22-4"></span>    
<span class="anchor" id="line-23-3"></span>    * G1
<span class="anchor" id="line-24-3"></span>* Minor GC/Major GC/Mixed GC/Full GC
<span class="anchor" id="line-25-3"></span>    * jstat里列出的GC指的是STW
<span class="anchor" id="line-26-3"></span>    * gc log则是列出了所有的信息
<span class="anchor" id="line-27-3"></span>* 垃圾收集与RAII的比较 *</pre><p class="line874"> <span class="anchor" id="line-688"></span><span class="anchor" id="line-689"></span><p class="line874">{{ <span class="anchor" id="line-690"></span><span class="anchor" id="line-691"></span><p class="line874">* 结构 <span class="anchor" id="line-692"></span><ul><li>魔数与版本 <span class="anchor" id="line-693"></span></li><li>常量池 <span class="anchor" id="line-694"></span></li><li>访问标志 <span class="anchor" id="line-695"></span></li><li>类索引、父类索引与接口索引 <span class="anchor" id="line-696"></span></li><li>字段表 <span class="anchor" id="line-697"></span></li><li>方法表 <span class="anchor" id="line-698"></span></li></ul><p class="line867"><span class="u">_ <span class="anchor" id="line-699"></span>}} <span class="anchor" id="line-700"></span><span class="anchor" id="line-701"></span><p class="line867"><span class="anchor" id="line-702"></span><span class="anchor" id="line-703"></span><span class="anchor" id="line-704"></span><span class="anchor" id="line-705"></span><span class="anchor" id="line-706"></span><span class="anchor" id="line-707"></span><span class="anchor" id="line-708"></span><span class="anchor" id="line-709"></span><span class="anchor" id="line-710"></span><span class="anchor" id="line-711"></span><span class="anchor" id="line-712"></span><pre><span class="anchor" id="line-1-14"></span>### 类加载
<span class="anchor" id="line-2-14"></span>* 加载过程
<span class="anchor" id="line-3-13"></span>    * 加载
<span class="anchor" id="line-4-12"></span>    * 连接 - 验证，准备，解析
<span class="anchor" id="line-5-12"></span>    * 初始化
<span class="anchor" id="line-6-11"></span>        * &lt;clinit&gt;()和&lt;init&gt;()
<span class="anchor" id="line-7-11"></span>    * 使用
<span class="anchor" id="line-8-10"></span>    * 卸载
<span class="anchor" id="line-9-8"></span>* 虚拟机严格规定了初始化的场景（主动引用）
<span class="anchor" id="line-10-7"></span>* 类加载器的双亲委派模型
<span class="anchor" id="line-11-7"></span>* 怎么判断两个类相同</pre><span class="anchor" id="line-713"></span><span class="anchor" id="line-714"></span><p class="line867"><span class="anchor" id="line-715"></span><span class="anchor" id="line-716"></span><span class="anchor" id="line-717"></span><span class="anchor" id="line-718"></span><span class="anchor" id="line-719"></span><span class="anchor" id="line-720"></span><span class="anchor" id="line-721"></span><span class="anchor" id="line-722"></span><span class="anchor" id="line-723"></span><span class="anchor" id="line-724"></span><span class="anchor" id="line-725"></span><span class="anchor" id="line-726"></span><pre><span class="anchor" id="line-1-15"></span>### 执行字节码
<span class="anchor" id="line-2-15"></span>* 栈帧
<span class="anchor" id="line-3-14"></span>    * 局部变量表
<span class="anchor" id="line-4-13"></span>    * 操作数栈
<span class="anchor" id="line-5-13"></span>    * 返回地址
<span class="anchor" id="line-6-12"></span>* 方法调用
<span class="anchor" id="line-7-12"></span>    * 解析调用
<span class="anchor" id="line-8-11"></span>    * 分派调用
<span class="anchor" id="line-9-9"></span>        * 静态 vs 动态
<span class="anchor" id="line-10-8"></span>        * 单分派 vs 多分派
<span class="anchor" id="line-11-8"></span>* 基于栈 vs 基于寄存器</pre><span class="anchor" id="line-727"></span><span class="anchor" id="line-728"></span><p class="line867"><span class="anchor" id="line-729"></span><span class="anchor" id="line-730"></span><span class="anchor" id="line-731"></span><span class="anchor" id="line-732"></span><span class="anchor" id="line-733"></span><span class="anchor" id="line-734"></span><span class="anchor" id="line-735"></span><span class="anchor" id="line-736"></span><span class="anchor" id="line-737"></span><span class="anchor" id="line-738"></span><span class="anchor" id="line-739"></span><span class="anchor" id="line-740"></span><span class="anchor" id="line-741"></span><span class="anchor" id="line-742"></span><span class="anchor" id="line-743"></span><span class="anchor" id="line-744"></span><span class="anchor" id="line-745"></span><span class="anchor" id="line-746"></span><span class="anchor" id="line-747"></span><span class="anchor" id="line-748"></span><span class="anchor" id="line-749"></span><span class="anchor" id="line-750"></span><span class="anchor" id="line-751"></span><span class="anchor" id="line-752"></span><span class="anchor" id="line-753"></span><span class="anchor" id="line-754"></span><pre><span class="anchor" id="line-1-16"></span>### 编译
<span class="anchor" id="line-2-16"></span>* AOT
<span class="anchor" id="line-3-15"></span>    * 前端/优化器/后端
<span class="anchor" id="line-4-14"></span>* Javac
<span class="anchor" id="line-5-14"></span>
<span class="anchor" id="line-6-13"></span>---
<span class="anchor" id="line-7-13"></span>### 运行时优化
<span class="anchor" id="line-8-12"></span>* 解释器与编译器并存
<span class="anchor" id="line-9-10"></span>    * 分层编译
<span class="anchor" id="line-10-9"></span>    * Server模式和Client模式*
<span class="anchor" id="line-11-9"></span>* 即时编译 JIT
<span class="anchor" id="line-12-7"></span>    * 热点探测 Hot Span Detection
<span class="anchor" id="line-13-6"></span>    * 栈上替换 On Stack Replacement
<span class="anchor" id="line-14-6"></span>* 运行期优化
<span class="anchor" id="line-15-5"></span>
<span class="anchor" id="line-16-5"></span>---
<span class="anchor" id="line-17-5"></span>
<span class="anchor" id="line-18-5"></span>### 编译器 vs 解释器 vs 虚拟机
<span class="anchor" id="line-19-5"></span>
<span class="anchor" id="line-20-5"></span>Override 动态分配
<span class="anchor" id="line-21-5"></span>Overload 静态分配
<span class="anchor" id="line-22-5"></span>参数静态分配
<span class="anchor" id="line-23-4"></span>前面调用的是动态分配</pre><span class="anchor" id="line-755"></span><span class="anchor" id="line-756"></span><span class="anchor" id="line-757"></span><p class="line867">
<h2 id="July_20">July 20</h2>
<span class="anchor" id="line-758"></span><p class="line867">
<h3 id="A.2BlsZPU1tmTmA_JVM.2BjANPGA-">集体学习 JVM调优</h3>
<span class="anchor" id="line-759"></span><p class="line867"><span class="anchor" id="line-760"></span><span class="anchor" id="line-761"></span><span class="anchor" id="line-762"></span><span class="anchor" id="line-763"></span><span class="anchor" id="line-764"></span><span class="anchor" id="line-765"></span><span class="anchor" id="line-766"></span><span class="anchor" id="line-767"></span><span class="anchor" id="line-768"></span><span class="anchor" id="line-769"></span><span class="anchor" id="line-770"></span><span class="anchor" id="line-771"></span><span class="anchor" id="line-772"></span><span class="anchor" id="line-773"></span><span class="anchor" id="line-774"></span><span class="anchor" id="line-775"></span><span class="anchor" id="line-776"></span><span class="anchor" id="line-777"></span><span class="anchor" id="line-778"></span><span class="anchor" id="line-779"></span><span class="anchor" id="line-780"></span><span class="anchor" id="line-781"></span><span class="anchor" id="line-782"></span><span class="anchor" id="line-783"></span><span class="anchor" id="line-784"></span><span class="anchor" id="line-785"></span><span class="anchor" id="line-786"></span><span class="anchor" id="line-787"></span><span class="anchor" id="line-788"></span><span class="anchor" id="line-789"></span><span class="anchor" id="line-790"></span><span class="anchor" id="line-791"></span><span class="anchor" id="line-792"></span><span class="anchor" id="line-793"></span><span class="anchor" id="line-794"></span><span class="anchor" id="line-795"></span><span class="anchor" id="line-796"></span><span class="anchor" id="line-797"></span><span class="anchor" id="line-798"></span><span class="anchor" id="line-799"></span><span class="anchor" id="line-800"></span><span class="anchor" id="line-801"></span><span class="anchor" id="line-802"></span><span class="anchor" id="line-803"></span><span class="anchor" id="line-804"></span><span class="anchor" id="line-805"></span><span class="anchor" id="line-806"></span><span class="anchor" id="line-807"></span><span class="anchor" id="line-808"></span><span class="anchor" id="line-809"></span><span class="anchor" id="line-810"></span><span class="anchor" id="line-811"></span><span class="anchor" id="line-812"></span><span class="anchor" id="line-813"></span><span class="anchor" id="line-814"></span><span class="anchor" id="line-815"></span><span class="anchor" id="line-816"></span><span class="anchor" id="line-817"></span><span class="anchor" id="line-818"></span><span class="anchor" id="line-819"></span><span class="anchor" id="line-820"></span><pre><span class="anchor" id="line-1-17"></span>调优目的： 吞吐量， 延迟，内存占用 
<span class="anchor" id="line-2-17"></span>调优参数：性能参数，行为参数，调试参数
<span class="anchor" id="line-3-16"></span>调优远离： 和 垃圾回收机制有关
<span class="anchor" id="line-4-15"></span>-Xmn -&gt;新生代内存
<span class="anchor" id="line-5-15"></span>-Xms -&gt;JVM 启动时候可申请的最小内存
<span class="anchor" id="line-6-14"></span>-Xmx -&gt;JVM 可申请的最大heap内存
<span class="anchor" id="line-7-14"></span>-XX: SurvivorRation-&gt;Eden 和S0 或者 S1 区的比例
<span class="anchor" id="line-8-13"></span>-XX: NewRatio 新生到和老年代比例
<span class="anchor" id="line-9-11"></span>-XX: NewSize 新生代空间
<span class="anchor" id="line-10-10"></span>-XX: MaxTenringThreshold: 对象进入老年的年龄阈值
<span class="anchor" id="line-11-10"></span>-XX:-UseSerialGC, serial&amp;serial old      (client默认模式)
<span class="anchor" id="line-12-8"></span>-XX:-UseParallelGC,  parallel scavenge&amp; parral old  server默认模式
<span class="anchor" id="line-13-7"></span>-XX:-UseConcMarkSweepGC,  ParNew+CMS
<span class="anchor" id="line-14-7"></span>XX:+UseG1GC
<span class="anchor" id="line-15-6"></span>
<span class="anchor" id="line-16-6"></span>jps: 查看jvm进程
<span class="anchor" id="line-17-6"></span>jmap：提供 JVM 内存使用信息，适用于脚本中。
<span class="anchor" id="line-18-6"></span>jmap
<span class="anchor" id="line-19-6"></span>
<span class="anchor" id="line-20-6"></span>用于显示当前Java堆和永久代的详细信息（如当前使用的收集器，当前的空间使用率等）
<span class="anchor" id="line-21-6"></span>   -dump:生成java堆转储快照
<span class="anchor" id="line-22-6"></span>   -heap:显示java堆详细信息(只在Linux/Solaris下有效)
<span class="anchor" id="line-23-5"></span>   -F:当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照(只在Linux/Solaris下有效)
<span class="anchor" id="line-24-4"></span>   -finalizerinfo:显示在F-Queue中等待Finalizer线程执行finalize方法的对象(只在Linux/Solaris下有效)
<span class="anchor" id="line-25-4"></span>   -histo:显示堆中对象统计信息
<span class="anchor" id="line-26-4"></span>   -permstat:以ClassLoader为统计口径显示永久代内存状态(只在Linux/Solaris下有效
<span class="anchor" id="line-27-4"></span> 命令格式:jmap [option] vmid
<span class="anchor" id="line-28-3"></span>
<span class="anchor" id="line-29-3"></span>jinfo：访问 JVM 系统属性，同时可以动态修改这些属性。
<span class="anchor" id="line-30-2"></span>jstack：提供 Java 进程内的线程堆栈信息。
<span class="anchor" id="line-31-1"></span>jstack
<span class="anchor" id="line-32-1"></span>用于生成当前JVM的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法,目的是定位线程出现长时间停顿的原因。
<span class="anchor" id="line-33-1"></span>   -F:当正常输出的请求不被响应时，强制输出线程堆栈
<span class="anchor" id="line-34-1"></span>   -l:除堆栈外，显示关于锁的附加信息
<span class="anchor" id="line-35-1"></span>   -m:如果调用到本地方法的话，可以显示C/C++的堆栈
<span class="anchor" id="line-36-1"></span>命令格式:jstack [option] vmid
<span class="anchor" id="line-37-1"></span>
<span class="anchor" id="line-38-1"></span> 
<span class="anchor" id="line-39-1"></span>jstat：提供 Java 垃圾回收以及类加载信息。
<span class="anchor" id="line-40-1"></span>jstat可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据
<span class="anchor" id="line-41-1"></span>   -class:监视类装载、卸载数量、总空间及类装载所耗费的时间
<span class="anchor" id="line-42-1"></span>   -gc:监听Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量，以用空间、GC时间合计等信息
<span class="anchor" id="line-43-1"></span>   -gccapacity:监视内容与-gc基本相同，但输出主要关注java堆各个区域使用到的最大和最小空间
<span class="anchor" id="line-44-1"></span>   -gcutil:监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比
<span class="anchor" id="line-45-1"></span>   -gccause:与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因
<span class="anchor" id="line-46-1"></span>   -gcnew:监视新生代GC状况
<span class="anchor" id="line-47-1"></span>   -gcnewcapacity:监视内同与-gcnew基本相同，输出主要关注使用到的最大和最小空间
<span class="anchor" id="line-48-1"></span>   -gcold:监视老年代GC情况
<span class="anchor" id="line-49-1"></span>
<span class="anchor" id="line-50-1"></span>jconsole：提供 JVM 活动的图形化展示，包括线程使用，类使用以及垃圾回收（GC）信息。
<span class="anchor" id="line-51-1"></span>Java mission control
<span class="anchor" id="line-52-1"></span>Memory analyzer tool
<span class="anchor" id="line-53-1"></span>远程调试
<span class="anchor" id="line-54-1"></span>
<span class="anchor" id="line-55-1"></span>
<span class="anchor" id="line-56-1"></span>-verbosegc配合使用的一些常用参数为：
<span class="anchor" id="line-57-1"></span>   -XX:+PrintGCDetails，打印GC信息，这是-verbosegc默认开启的选项
<span class="anchor" id="line-58-1"></span>   -XX:+PrintGCTimeStamps，打印每次GC的时间戳
<span class="anchor" id="line-59-1"></span>   -XX:+PrintHeapAtGC：每次GC时，打印堆信息
<span class="anchor" id="line-60-1"></span>   -XX:+PrintGCDateStamps (from JDK 6 update 4) ：打印GC日期，适合于长期运行的服务器</pre><span class="anchor" id="line-821"></span><span class="anchor" id="line-822"></span><p class="line867">
<h2 id="July_21-26">July 21-26</h2>
<span class="anchor" id="line-823"></span><p class="line867">
<h3 id="Redis_.2BThpSoVtmTmA-">Redis 业务学习</h3>
<span class="anchor" id="line-824"></span><p class="line867"><span class="anchor" id="line-825"></span><span class="anchor" id="line-826"></span><span class="anchor" id="line-827"></span><span class="anchor" id="line-828"></span><span class="anchor" id="line-829"></span><span class="anchor" id="line-830"></span><span class="anchor" id="line-831"></span><span class="anchor" id="line-832"></span><span class="anchor" id="line-833"></span><span class="anchor" id="line-834"></span><pre><span class="anchor" id="line-1-18"></span>redis单线程
<span class="anchor" id="line-2-18"></span>支持两种数据持久化方式：Snapshotting（快照）和 Append Only file（追加到日志记录文件）
<span class="anchor" id="line-3-17"></span>Redis是一个高性能的 key-value 对存储系统。它支持存储的value类型很多，包括string（字符串）、list（链表）、hash（哈希）、set（无序集合）、zset（有序集合）
<span class="anchor" id="line-4-16"></span>支持两种数据持久化方式：Snapshotting（快照）和 Append Only file（追加到日志记录文件）
<span class="anchor" id="line-5-16"></span>
<span class="anchor" id="line-6-15"></span>关于并发
<span class="anchor" id="line-7-15"></span>如果你的所有操作都是靠redis本身的机制保持原子性 不要锁也可以
<span class="anchor" id="line-8-14"></span>如果存在读数据，写redis要保证这个数据在并发的时候是一致的。</pre><span class="anchor" id="line-835"></span><p class="line867">
<h3 id="New-Bull_.2BXnZT0X8Wegt1MW1FUWVt8Q-">New-Bull 并发编程由浅入深</h3>
<span class="anchor" id="line-836"></span><p class="line867"><span class="anchor" id="line-837"></span><span class="anchor" id="line-838"></span><span class="anchor" id="line-839"></span><span class="anchor" id="line-840"></span><span class="anchor" id="line-841"></span><span class="anchor" id="line-842"></span><span class="anchor" id="line-843"></span><span class="anchor" id="line-844"></span><span class="anchor" id="line-845"></span><span class="anchor" id="line-846"></span><span class="anchor" id="line-847"></span><span class="anchor" id="line-848"></span><span class="anchor" id="line-849"></span><span class="anchor" id="line-850"></span><span class="anchor" id="line-851"></span><span class="anchor" id="line-852"></span><span class="anchor" id="line-853"></span><span class="anchor" id="line-854"></span><span class="anchor" id="line-855"></span><span class="anchor" id="line-856"></span><span class="anchor" id="line-857"></span><span class="anchor" id="line-858"></span><span class="anchor" id="line-859"></span><span class="anchor" id="line-860"></span><span class="anchor" id="line-861"></span><span class="anchor" id="line-862"></span><span class="anchor" id="line-863"></span><span class="anchor" id="line-864"></span><span class="anchor" id="line-865"></span><span class="anchor" id="line-866"></span><span class="anchor" id="line-867"></span><span class="anchor" id="line-868"></span><span class="anchor" id="line-869"></span><span class="anchor" id="line-870"></span><span class="anchor" id="line-871"></span><span class="anchor" id="line-872"></span><span class="anchor" id="line-873"></span><span class="anchor" id="line-874"></span><span class="anchor" id="line-875"></span><span class="anchor" id="line-876"></span><span class="anchor" id="line-877"></span><span class="anchor" id="line-878"></span><span class="anchor" id="line-879"></span><span class="anchor" id="line-880"></span><span class="anchor" id="line-881"></span><span class="anchor" id="line-882"></span><span class="anchor" id="line-883"></span><span class="anchor" id="line-884"></span><span class="anchor" id="line-885"></span><span class="anchor" id="line-886"></span><span class="anchor" id="line-887"></span><span class="anchor" id="line-888"></span><span class="anchor" id="line-889"></span><span class="anchor" id="line-890"></span><span class="anchor" id="line-891"></span><span class="anchor" id="line-892"></span><span class="anchor" id="line-893"></span><span class="anchor" id="line-894"></span><span class="anchor" id="line-895"></span><span class="anchor" id="line-896"></span><span class="anchor" id="line-897"></span><span class="anchor" id="line-898"></span><span class="anchor" id="line-899"></span><span class="anchor" id="line-900"></span><span class="anchor" id="line-901"></span><span class="anchor" id="line-902"></span><span class="anchor" id="line-903"></span><span class="anchor" id="line-904"></span><span class="anchor" id="line-905"></span><span class="anchor" id="line-906"></span><span class="anchor" id="line-907"></span><span class="anchor" id="line-908"></span><span class="anchor" id="line-909"></span><span class="anchor" id="line-910"></span><span class="anchor" id="line-911"></span><span class="anchor" id="line-912"></span><span class="anchor" id="line-913"></span><span class="anchor" id="line-914"></span><span class="anchor" id="line-915"></span><span class="anchor" id="line-916"></span><span class="anchor" id="line-917"></span><span class="anchor" id="line-918"></span><span class="anchor" id="line-919"></span><span class="anchor" id="line-920"></span><span class="anchor" id="line-921"></span><span class="anchor" id="line-922"></span><span class="anchor" id="line-923"></span><span class="anchor" id="line-924"></span><span class="anchor" id="line-925"></span><span class="anchor" id="line-926"></span><span class="anchor" id="line-927"></span><span class="anchor" id="line-928"></span><span class="anchor" id="line-929"></span><span class="anchor" id="line-930"></span><span class="anchor" id="line-931"></span><span class="anchor" id="line-932"></span><span class="anchor" id="line-933"></span><span class="anchor" id="line-934"></span><span class="anchor" id="line-935"></span><span class="anchor" id="line-936"></span><span class="anchor" id="line-937"></span><span class="anchor" id="line-938"></span><span class="anchor" id="line-939"></span><span class="anchor" id="line-940"></span><span class="anchor" id="line-941"></span><span class="anchor" id="line-942"></span><span class="anchor" id="line-943"></span><span class="anchor" id="line-944"></span><span class="anchor" id="line-945"></span><span class="anchor" id="line-946"></span><span class="anchor" id="line-947"></span><span class="anchor" id="line-948"></span><span class="anchor" id="line-949"></span><pre><span class="anchor" id="line-1-19"></span>### 基本概念
<span class="anchor" id="line-2-19"></span> * 并发与并行
<span class="anchor" id="line-3-18"></span> * 讨论: 写对并发代码的挑战
<span class="anchor" id="line-4-17"></span>1. 设计好共享状态
<span class="anchor" id="line-5-17"></span>2.  状态设计. 以Servlet 为例， servlet 是共享的. “Servlet 要无状态
<span class="anchor" id="line-6-16"></span>3. 时序的问题
<span class="anchor" id="line-7-16"></span>4. 优化为了达到线程安全所花费的开销，主要是锁
<span class="anchor" id="line-8-15"></span>
<span class="anchor" id="line-9-12"></span>什么是线程安全的？
<span class="anchor" id="line-10-11"></span>一个模块是线程安全，多线程调它的接 ，结果逻辑正确/符合预期.
<span class="anchor" id="line-11-11"></span>要求调 者需要加锁、需要某种时序的保证
<span class="anchor" id="line-12-9"></span>
<span class="anchor" id="line-13-8"></span>坑： RMW. Read-Modify-Write
<span class="anchor" id="line-14-8"></span>典型的坑：
<span class="anchor" id="line-15-7"></span>case 1: ConcurrentModificationException
<span class="anchor" id="line-16-7"></span>fail fast : ArrayList.checkForComodification()
<span class="anchor" id="line-17-7"></span>https://coolshell.cn/articles/9606.html rehash 导致hashmap死循环
<span class="anchor" id="line-18-7"></span>内存缓存 deepCopy()
<span class="anchor" id="line-19-7"></span>
<span class="anchor" id="line-20-7"></span>为什么要有并发？ 利用多核， 设计上贴近现实世界。
<span class="anchor" id="line-21-7"></span>---
<span class="anchor" id="line-22-7"></span>
<span class="anchor" id="line-23-6"></span>### 几个核心概念
<span class="anchor" id="line-24-5"></span> * 原子操作 : 并发场景的基本需求， 也是互斥、同步 实现的前提
<span class="anchor" id="line-25-5"></span> * 互斥 : 并发场景的基本需求
<span class="anchor" id="line-26-5"></span> * 同步 : 并发实体之间的通讯
<span class="anchor" id="line-27-5"></span> * 可见性 : 解决底层并发性能优化带来的副作用
<span class="anchor" id="line-28-4"></span>
<span class="anchor" id="line-29-4"></span>原子操作；  boolean Unsafe.compareAndSwap /Unsafe.objectFieldOffset(AtomicInteger.field(“value”))
<span class="anchor" id="line-30-3"></span>常见的互斥机制 ? 锁 信号量 Synchronized
<span class="anchor" id="line-31-2"></span>同步 Object.wait Object.notify 
<span class="anchor" id="line-32-2"></span>Lock.condition
<span class="anchor" id="line-33-2"></span> notify/signal 还是 notifyAll/signalAll 
<span class="anchor" id="line-34-2"></span>避免liveness VS “惊群效应” (thundering herd)
<span class="anchor" id="line-35-2"></span>
<span class="anchor" id="line-36-2"></span>可见性 — Java
<span class="anchor" id="line-37-2"></span>内存屏障
<span class="anchor" id="line-38-2"></span>
<span class="anchor" id="line-39-2"></span>同步 : 并发实体之间的通讯
<span class="anchor" id="line-40-2"></span>可 性 : 解决底层并发性能优化带来的副作 
<span class="anchor" id="line-41-2"></span>
<span class="anchor" id="line-42-2"></span>### 原子操作
<span class="anchor" id="line-43-2"></span> * CAS, CompareAndSwap
<span class="anchor" id="line-44-2"></span> * Java 原子操作的支持
<span class="anchor" id="line-45-2"></span>
<span class="anchor" id="line-46-2"></span>---
<span class="anchor" id="line-47-2"></span>
<span class="anchor" id="line-48-2"></span>### 互斥
<span class="anchor" id="line-49-2"></span> * 常见的互斥机制
<span class="anchor" id="line-50-2"></span> * Java 互斥机制的相关实现
<span class="anchor" id="line-51-2"></span>
<span class="anchor" id="line-52-2"></span>---
<span class="anchor" id="line-53-2"></span>
<span class="anchor" id="line-54-2"></span>### 同步
<span class="anchor" id="line-55-2"></span> * Object .wait() .notify()
<span class="anchor" id="line-56-2"></span> * Lock.condition
<span class="anchor" id="line-57-2"></span> * Future
<span class="anchor" id="line-58-2"></span> * 一些Helper类:  Semaphore, CountDownLatch 等
<span class="anchor" id="line-59-2"></span>
<span class="anchor" id="line-60-2"></span>---
<span class="anchor" id="line-61-1"></span>
<span class="anchor" id="line-62-1"></span>### 可见性
<span class="anchor" id="line-63-1"></span> * 可见性问题存在的原因
<span class="anchor" id="line-64-1"></span> * volatile. 内存屏障. Java 内存模型
<span class="anchor" id="line-65-1"></span>
<span class="anchor" id="line-66-1"></span>---
<span class="anchor" id="line-67-1"></span>
<span class="anchor" id="line-68-1"></span>### Concurrent Collection
<span class="anchor" id="line-69-1"></span>
<span class="anchor" id="line-70-1"></span>---
<span class="anchor" id="line-71-1"></span>
<span class="anchor" id="line-72-1"></span>### Java 线程池实现 ThreadPoolExecutor
<span class="anchor" id="line-73-1"></span> * 运行机制剖析
<span class="anchor" id="line-74-1"></span> * 使用原则
<span class="anchor" id="line-75-1"></span>
<span class="anchor" id="line-76-1"></span>为了线程复用以及控制资源开销
<span class="anchor" id="line-77-1"></span>
<span class="anchor" id="line-78-1"></span>各个参数意义：
<span class="anchor" id="line-79-1"></span>当execute(task) 时:
<span class="anchor" id="line-80-1"></span>如果当前线程数 &lt; corePoolSize, 则创建新线程. ( 即使当前线程中有idle的 /!\ )
<span class="anchor" id="line-81-1"></span>
<span class="anchor" id="line-82-1"></span>如过当前线程数 &gt;= corePoolSize, 则进队列. ( idle 的线程会从队列取task )
<span class="anchor" id="line-83"></span>
<span class="anchor" id="line-84"></span>如果队列满了且当前线程数 &lt; maxPoolSize, 则新建线程来处理
<span class="anchor" id="line-85"></span>
<span class="anchor" id="line-86"></span>否则 调用 RejectedExecutionHandler 进行处理
<span class="anchor" id="line-87"></span>
<span class="anchor" id="line-88"></span>keepAliveTime
<span class="anchor" id="line-89"></span>&gt; coreSize &lt; maxSize 的线程在ilde时间超过这个阈值时会被销毁
<span class="anchor" id="line-90"></span>
<span class="anchor" id="line-91"></span>pool.allowCoreThreadTimeOut(true) 可使得 &lt;= coreSize 的线程也参照这个keepActiveTime
<span class="anchor" id="line-92"></span>
<span class="anchor" id="line-93"></span>队列
<span class="anchor" id="line-94"></span>队列的类型用于在 资源控制 和 吞吐之间做权衡
<span class="anchor" id="line-95"></span>不限制capacity 的 LinkedBlockingQueue, 则maxSize无效. 吞吐受限于coreSize, 也减少了线程的创建及context switch 等开销.
<span class="anchor" id="line-96"></span>
<span class="anchor" id="line-97"></span>SynchronousQueue. 如果有当前thread有idle的则可 "进队列" (特殊的长度为0的队列)， 否则创建新的线程. 保证了吞吐
<span class="anchor" id="line-98"></span>
<span class="anchor" id="line-99"></span>ArrayBlockingQueue, 上两种队列的一种平衡
<span class="anchor" id="line-100"></span>
<span class="anchor" id="line-101"></span>
<span class="anchor" id="line-102"></span>---
<span class="anchor" id="line-103"></span>
<span class="anchor" id="line-104"></span>### ForkjoinPool 框架及 ParallelStream
<span class="anchor" id="line-105"></span>Map &amp; Reduce = Divide &amp; Conquer = Fork &amp; Join
<span class="anchor" id="line-106"></span>---
<span class="anchor" id="line-107"></span>
<span class="anchor" id="line-108"></span>### 其它
<span class="anchor" id="line-109"></span> * ThreadLocal
<span class="anchor" id="line-110"></span></pre><span class="anchor" id="line-950"></span><span class="anchor" id="line-951"></span><p class="line867">
<h3 id="A.2Bfud.2B7Q-Tutor-team_.2BThpSoWV0dAY-">继续Tutor-team 业务整理</h3>
<span class="anchor" id="line-952"></span><span class="anchor" id="line-953"></span><p class="line867">
<h2 id="July_29">July 29</h2>
<span class="anchor" id="line-954"></span><p class="line867">
<h3 id="A.2BTgNZKU4Di.2B2KAA-">七天七语言</h3>
<span class="anchor" id="line-955"></span><p class="line874">主要就是学习到了其他语言的一些编程思想 <span class="anchor" id="line-956"></span><span class="anchor" id="line-957"></span><span class="anchor" id="line-958"></span><span class="anchor" id="line-959"></span><span class="anchor" id="line-960"></span><span class="anchor" id="line-961"></span><span class="anchor" id="line-962"></span><span class="anchor" id="line-963"></span><span class="anchor" id="line-964"></span><span class="anchor" id="line-965"></span><span class="anchor" id="line-966"></span><span class="anchor" id="line-967"></span><span class="anchor" id="line-968"></span><pre><span class="anchor" id="line-1-20"></span>闭包是一个函数/方法
<span class="anchor" id="line-2-20"></span>你可以向传递对象那样传递它, 以后调用
<span class="anchor" id="line-3-19"></span>当这个函数创建的时候, 它记住了该环境下所有的变量的值. 被调用时, 它可以一直访问这些变量, 甚至这些变量已处于环境的外部.
<span class="anchor" id="line-4-18"></span>
<span class="anchor" id="line-5-18"></span>语言：
<span class="anchor" id="line-6-17"></span>主要是看是不是在运行期才会报类型不一致错误
<span class="anchor" id="line-7-17"></span>静态类型
<span class="anchor" id="line-8-16"></span>动态类型
<span class="anchor" id="line-9-13"></span>
<span class="anchor" id="line-10-12"></span>鸭子类型 
<span class="anchor" id="line-11-12"></span>behave as a</pre><span class="anchor" id="line-969"></span><span class="anchor" id="line-970"></span><p class="line867">
<h2 id="July_31">July 31</h2>
<span class="anchor" id="line-971"></span><p class="line867">
<h3 id="A.2BZw1SoWV0dAY-">服务整理</h3>
<span class="anchor" id="line-972"></span><p class="line874">主要是team 相关资源的 redis crud操作。 <span class="anchor" id="line-973"></span><span class="anchor" id="line-974"></span><p class="line867"><hr class="hr6" /><p class="line874"> <span class="anchor" id="line-975"></span>
<h2 id="Aug_1">Aug 1</h2>
<span class="anchor" id="line-976"></span><p class="line867">
<h3 id="A.2BW2ZOYA-redis.2BdvhRc3UobNU-">学习redis相关用法</h3>
<span class="anchor" id="line-977"></span><p class="line867"><span class="anchor" id="line-978"></span><span class="anchor" id="line-979"></span><pre><span class="anchor" id="line-1-21"></span>用redisClinet.callByRead/callByWrite，免得自己来释放</pre><span class="anchor" id="line-980"></span><span class="anchor" id="line-981"></span><p class="line867">
<h2 id="Aug_2">Aug 2</h2>
<span class="anchor" id="line-982"></span><p class="line867">
<h3 id="A.2BZbByW1tmTmA_--_.2Bi76LoWVwY25bxpbGV4telHUo-">新牛学习 -- 设计数据密集型应用</h3>
<span class="anchor" id="line-983"></span><p class="line874">《设计数据密集型应用》前三章， SST 和 LSM tree <span class="anchor" id="line-984"></span><span class="anchor" id="line-985"></span><span class="anchor" id="line-986"></span><p class="line867">
<h3 id="A.2Bfud.2B7Q-tutor-team.2BZw1SoWV0dAb.2FDGXgV1E-">继续tutor-team服务整理，无坑</h3>
<span class="anchor" id="line-987"></span><span class="anchor" id="line-988"></span><p class="line867">
<h2 id="Aug_3">Aug 3</h2>
<span class="anchor" id="line-989"></span><p class="line867">
<h3 id="A.2BW.2FxR.2Bouoi7pTOmXlX9c-">导出讨论区日志</h3>
<span class="anchor" id="line-990"></span><p class="line867"><span class="anchor" id="line-991"></span><span class="anchor" id="line-992"></span><pre><span class="anchor" id="line-1-22"></span>sql limit offset 第一次使用</pre><span class="anchor" id="line-993"></span><span class="anchor" id="line-994"></span><p class="line867">
<h3 id="A.2BeyxOAGshdTOL9w-redis">第一次申请redis</h3>
<span class="anchor" id="line-995"></span><p class="line874">熟悉提供单，命名规则等 <span class="anchor" id="line-996"></span><span class="anchor" id="line-997"></span><p class="line867">
<h2 id="Aug_4">Aug 4</h2>
<span class="anchor" id="line-998"></span><p class="line867">
<h3 id="A.2BW2ZOYIu.2Bi6FlcGNuW8aWxleLXpR1KA-">学习设计数据密集型应用</h3>
<span class="anchor" id="line-999"></span><span class="anchor" id="line-1000"></span><p class="line867">
<h2 id="Aug_6">Aug 6</h2>
<span class="anchor" id="line-1001"></span><p class="line867">
<h3 id="A.2BUhte.2Bg-Job_.2BV1E-">创建Job 坑</h3>
<span class="anchor" id="line-1002"></span><p class="line874">今天再次有新建Job的需求，又遇到了IDE的坑。 <span class="anchor" id="line-1003"></span>解决办法： <span class="anchor" id="line-1004"></span>把原代码push上去， 删除本地代码，再pull回来。 <span class="anchor" id="line-1005"></span>蜜汁解决，应该是IDE的毛病？ <span class="anchor" id="line-1006"></span><span class="anchor" id="line-1007"></span><p class="line867">
<h2 id="Aug_7_.26.26_Aug_8">Aug 7 &amp;&amp; Aug 8</h2>
<span class="anchor" id="line-1008"></span><p class="line867">
<h3 id="A.2BU81gHQ-">反思</h3>
<span class="anchor" id="line-1009"></span><p class="line874">主要是写导数据以及验证结果的job， <span class="anchor" id="line-1010"></span>发现了以前写的代码有点坑， 漏了注解，以及有的提交没法运行， 还有配置文件没有配全。 <span class="anchor" id="line-1011"></span>以后要保证不光可以编译通过，也可以跑起来！！！ <span class="anchor" id="line-1012"></span>
<h3 id="A.2BW2ZOYA-DDIA.2BeyxOA3rg-">学习DDIA第七章</h3>
<span class="anchor" id="line-1013"></span><p class="line874">应改会和 Aug 9 一起整理。 <span class="anchor" id="line-1014"></span><span class="anchor" id="line-1015"></span><p class="line867">
<h2 id="Aug_9">Aug 9</h2>
<span class="anchor" id="line-1016"></span><p class="line867">
<h3 id="A.2BW2ZOYA-DDIA">学习DDIA</h3>
<span class="anchor" id="line-1017"></span><p class="line867"><span class="anchor" id="line-1018"></span><span class="anchor" id="line-1019"></span><span class="anchor" id="line-1020"></span><span class="anchor" id="line-1021"></span><span class="anchor" id="line-1022"></span><span class="anchor" id="line-1023"></span><span class="anchor" id="line-1024"></span><span class="anchor" id="line-1025"></span><span class="anchor" id="line-1026"></span><span class="anchor" id="line-1027"></span><span class="anchor" id="line-1028"></span><span class="anchor" id="line-1029"></span><span class="anchor" id="line-1030"></span><span class="anchor" id="line-1031"></span><span class="anchor" id="line-1032"></span><span class="anchor" id="line-1033"></span><span class="anchor" id="line-1034"></span><span class="anchor" id="line-1035"></span><span class="anchor" id="line-1036"></span><span class="anchor" id="line-1037"></span><span class="anchor" id="line-1038"></span><span class="anchor" id="line-1039"></span><span class="anchor" id="line-1040"></span><span class="anchor" id="line-1041"></span><span class="anchor" id="line-1042"></span><span class="anchor" id="line-1043"></span><span class="anchor" id="line-1044"></span><span class="anchor" id="line-1045"></span><span class="anchor" id="line-1046"></span><span class="anchor" id="line-1047"></span><span class="anchor" id="line-1048"></span><span class="anchor" id="line-1049"></span><span class="anchor" id="line-1050"></span><span class="anchor" id="line-1051"></span><span class="anchor" id="line-1052"></span><span class="anchor" id="line-1053"></span><span class="anchor" id="line-1054"></span><span class="anchor" id="line-1055"></span><span class="anchor" id="line-1056"></span><span class="anchor" id="line-1057"></span><span class="anchor" id="line-1058"></span><span class="anchor" id="line-1059"></span><span class="anchor" id="line-1060"></span><span class="anchor" id="line-1061"></span><span class="anchor" id="line-1062"></span><span class="anchor" id="line-1063"></span><span class="anchor" id="line-1064"></span><span class="anchor" id="line-1065"></span><span class="anchor" id="line-1066"></span><span class="anchor" id="line-1067"></span><span class="anchor" id="line-1068"></span><span class="anchor" id="line-1069"></span><span class="anchor" id="line-1070"></span><span class="anchor" id="line-1071"></span><span class="anchor" id="line-1072"></span><span class="anchor" id="line-1073"></span><span class="anchor" id="line-1074"></span><span class="anchor" id="line-1075"></span><span class="anchor" id="line-1076"></span><span class="anchor" id="line-1077"></span><span class="anchor" id="line-1078"></span><span class="anchor" id="line-1079"></span><span class="anchor" id="line-1080"></span><span class="anchor" id="line-1081"></span><span class="anchor" id="line-1082"></span><span class="anchor" id="line-1083"></span><span class="anchor" id="line-1084"></span><span class="anchor" id="line-1085"></span><span class="anchor" id="line-1086"></span><span class="anchor" id="line-1087"></span><span class="anchor" id="line-1088"></span><span class="anchor" id="line-1089"></span><span class="anchor" id="line-1090"></span><span class="anchor" id="line-1091"></span><span class="anchor" id="line-1092"></span><span class="anchor" id="line-1093"></span><span class="anchor" id="line-1094"></span><span class="anchor" id="line-1095"></span><span class="anchor" id="line-1096"></span><span class="anchor" id="line-1097"></span><span class="anchor" id="line-1098"></span><span class="anchor" id="line-1099"></span><span class="anchor" id="line-1100"></span><span class="anchor" id="line-1101"></span><span class="anchor" id="line-1102"></span><span class="anchor" id="line-1103"></span><span class="anchor" id="line-1104"></span><span class="anchor" id="line-1105"></span><span class="anchor" id="line-1106"></span><span class="anchor" id="line-1107"></span><span class="anchor" id="line-1108"></span><span class="anchor" id="line-1109"></span><span class="anchor" id="line-1110"></span><span class="anchor" id="line-1111"></span><span class="anchor" id="line-1112"></span><span class="anchor" id="line-1113"></span><span class="anchor" id="line-1114"></span><span class="anchor" id="line-1115"></span><span class="anchor" id="line-1116"></span><span class="anchor" id="line-1117"></span><span class="anchor" id="line-1118"></span><span class="anchor" id="line-1119"></span><span class="anchor" id="line-1120"></span><span class="anchor" id="line-1121"></span><span class="anchor" id="line-1122"></span><span class="anchor" id="line-1123"></span><span class="anchor" id="line-1124"></span><span class="anchor" id="line-1125"></span><span class="anchor" id="line-1126"></span><span class="anchor" id="line-1127"></span><span class="anchor" id="line-1128"></span><span class="anchor" id="line-1129"></span><span class="anchor" id="line-1130"></span><span class="anchor" id="line-1131"></span><span class="anchor" id="line-1132"></span><span class="anchor" id="line-1133"></span><span class="anchor" id="line-1134"></span><span class="anchor" id="line-1135"></span><span class="anchor" id="line-1136"></span><span class="anchor" id="line-1137"></span><span class="anchor" id="line-1138"></span><span class="anchor" id="line-1139"></span><span class="anchor" id="line-1140"></span><span class="anchor" id="line-1141"></span><span class="anchor" id="line-1142"></span><span class="anchor" id="line-1143"></span><span class="anchor" id="line-1144"></span><span class="anchor" id="line-1145"></span><span class="anchor" id="line-1146"></span><span class="anchor" id="line-1147"></span><span class="anchor" id="line-1148"></span><span class="anchor" id="line-1149"></span><span class="anchor" id="line-1150"></span><span class="anchor" id="line-1151"></span><span class="anchor" id="line-1152"></span><span class="anchor" id="line-1153"></span><span class="anchor" id="line-1154"></span><span class="anchor" id="line-1155"></span><span class="anchor" id="line-1156"></span><span class="anchor" id="line-1157"></span><span class="anchor" id="line-1158"></span><span class="anchor" id="line-1159"></span><span class="anchor" id="line-1160"></span><span class="anchor" id="line-1161"></span><span class="anchor" id="line-1162"></span><span class="anchor" id="line-1163"></span><span class="anchor" id="line-1164"></span><span class="anchor" id="line-1165"></span><pre><span class="anchor" id="line-1-23"></span>## 讨论大纲
<span class="anchor" id="line-2-21"></span>### 可靠性、可扩展性、可维护性
<span class="anchor" id="line-3-20"></span>* 基本概念
<span class="anchor" id="line-4-19"></span>* 可靠性
<span class="anchor" id="line-5-19"></span>​ 系统在困境（adversity）（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）
<span class="anchor" id="line-6-18"></span>
<span class="anchor" id="line-7-18"></span>        * 提高可靠性的常用方法
<span class="anchor" id="line-8-17"></span>从三个方面去考虑即可。
<span class="anchor" id="line-9-14"></span>
<span class="anchor" id="line-10-13"></span>        * 是否一直以最高可靠性为开发目标？
<span class="anchor" id="line-11-13"></span>
<span class="anchor" id="line-12-10"></span>​ 在某些情况下，我们可能会选择牺牲可靠性来降低开发成本（例如为未经证实的市场开发产品原型）或运营成本（例如利润率极低的服务），但我们偷工减料时，应该清楚意识到自己在做什么。
<span class="anchor" id="line-13-9"></span>
<span class="anchor" id="line-14-9"></span>* 可扩展性
<span class="anchor" id="line-15-8"></span>​ 可扩展性（Scalability）是用来描述系统应对负载增长能力的术语
<span class="anchor" id="line-16-8"></span>        * Twitter 案例讨论
<span class="anchor" id="line-17-8"></span>        * 如何描述负载、性能
<span class="anchor" id="line-18-8"></span>首先要能简要描述系统的当前负载。负载可以用一些称为负载参数（load parameters）的数字来描述。参数的最佳选择取决于系统架构，它可能是每秒向Web服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率或其他东西。除此之外，也许平均情况对你很重要，也许你的瓶颈是少数极端场景
<span class="anchor" id="line-19-8"></span>一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看：
<span class="anchor" id="line-20-8"></span>增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？
<span class="anchor" id="line-21-8"></span>增加负载参数并希望保持性能不变时，需要增加多少系统资源？
<span class="anchor" id="line-22-8"></span>
<span class="anchor" id="line-23-7"></span>        * 响应时间avg min max  mean p99
<span class="anchor" id="line-24-6"></span>        * 了解SLI、SLO、SLA http://www.yunweipai.com/archives/10703.html
<span class="anchor" id="line-25-6"></span>        * 应对负载的方法
<span class="anchor" id="line-26-6"></span>人们经常讨论纵向扩展（scaling up）（垂直扩展（vertical scaling），转向更强大的机器）和横向扩展（scaling out）（水平扩展（horizontal scaling）
<span class="anchor" id="line-27-6"></span>​ 大规模的系统架构通常是应用特定的—— 没有一招鲜吃遍天的通用可扩展架构（不正式的叫法：万金油（magic scaling sauce） ）。应用的问题可能是读取量、写入量、要存储的数据量、数据的复杂度、响应时间要求、访问模式或者所有问题的大杂烩。
<span class="anchor" id="line-28-5"></span>
<span class="anchor" id="line-29-5"></span>
<span class="anchor" id="line-30-4"></span>### 数据模型与查询语言
<span class="anchor" id="line-31-3"></span>* 基本概念：关系模型、文档模型、图数据模型、NoSQL
<span class="anchor" id="line-32-3"></span>* 文档模型
<span class="anchor" id="line-33-3"></span>        * linkedIn 案例讨论
<span class="anchor" id="line-34-3"></span>        * 文档模型只能保存单一的文档，不能处理相对关系？no
<span class="anchor" id="line-35-3"></span>        * 文档模型是完全 schemaless 吗？ no
<span class="anchor" id="line-36-3"></span>文档数据库有时称为无模式（schemaless），但这具有误导性，因为读取数据的代码通常假定某种结构——即存在隐式模式，但不由数据库强制执行【20】。一个更精确的术语是读时模式（schema-on-read）（数据的结构是隐含的，只有在数据被读取时才被解释），相应的是写时模式（schema-on-write）（传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式）
<span class="anchor" id="line-37-3"></span>读时模式类似于编程语言中的动态（运行时）类型检查，而写时模式类似于静态（编译时）类型检查。就像静态和动态类型检查的相对优点具有很大的争议性一样【22】，数据库中模式的强制性是一个具有争议的话题，一般来说没有正确或错误的答案。
<span class="anchor" id="line-38-3"></span>读时模式更具优势，当由于某种原因（例如，数据是异构的）集合中的项目并不都具有相同的结构时。例如，因为：
<span class="anchor" id="line-39-3"></span>存在许多不同类型的对象，将每种类型的对象放在自己的表中是不现实的。
<span class="anchor" id="line-40-3"></span>数据的结构由外部系统决定。你无法控制外部系统且它随时可能变化。
<span class="anchor" id="line-41-3"></span>
<span class="anchor" id="line-42-3"></span>
<span class="anchor" id="line-43-3"></span>        * 文档模型能做的关系模型也能做？那文档模型的优势是什么？
<span class="anchor" id="line-44-3"></span>JSON表示中，所有相关信息都在同一个地方，一个查询就足够了。
<span class="anchor" id="line-45-3"></span>但是，在表示多对一和多对多的关系时，关系数据库和文档数据库并没有根本的不同：在这两种情况下，相关项目都被一个唯一的标识符引用，这个标识符在关系模型中被称为外键，在文档模型中称为文档引用【9】。该标识符在读取时通过连接或后续查询来解析。迄今为止，文档数据库没有走CODASYL的老路。
<span class="anchor" id="line-46-3"></span>
<span class="anchor" id="line-47-3"></span>很难说在一般情况下哪个数据模型让应用程序代码更简单；它取决于数据项之间存在的关系种类。对于高度相联的数据，选用文档模型是糟糕的，选用关系模型是可接受的，而选用图形模型（参见“图数据模型”）是最自然的。
<span class="anchor" id="line-48-3"></span>
<span class="anchor" id="line-49-3"></span>* 数据查询语言
<span class="anchor" id="line-50-3"></span>        * 声明式 VS 命令式
<span class="anchor" id="line-51-3"></span>SQL是一种声明式查询语言，而IMS和CODASYL使用命令式代码来查询数据库
<span class="anchor" id="line-52-3"></span>许多常用的编程语言是命令式的。例如，给定一个动物物种的列表，返回列表中的鲨鱼可以这样写
<span class="anchor" id="line-53-3"></span>        * MapReduce查询
<span class="anchor" id="line-54-3"></span> MapReduce既不是一个声明式的查询语言，也不是一个完全命令式的查询API，而是处于两者之间：查询的逻辑用代码片断来表示，这些代码片段会被处理框架重复性调用。它基于map（也称为collect）和reduce（也称为fold或inject）函数，两个函数存在于许多函数式编程语言中。
<span class="anchor" id="line-55-3"></span>
<span class="anchor" id="line-56-3"></span>文档数据库的应用场景是：数据通常是自我包含的，而且文档之间的关系非常稀少
<span class="anchor" id="line-57-3"></span>图形数据库用于相反的场景：任意事物都可能与任何事物相关联。
<span class="anchor" id="line-58-3"></span>
<span class="anchor" id="line-59-3"></span>### 存储与检索
<span class="anchor" id="line-60-3"></span>* 驱动数据库的数据结构
<span class="anchor" id="line-61-2"></span>        * hash索引
<span class="anchor" id="line-62-2"></span>                * 追加日志、分段压缩、删除记录
<span class="anchor" id="line-63-2"></span>                * 追加日志 VS 更新日志
<span class="anchor" id="line-64-2"></span>
<span class="anchor" id="line-65-2"></span>关于恢复数据：
<span class="anchor" id="line-66-2"></span>如果数据库重新启动，则内存散列映射将丢失。原则上，您可以通过从头到尾读取整个段文件并在每次按键时注意每个键的最近值的偏移量来恢复每个段的哈希映射。但是，如果段文件很大，这可能需要很长时间，这将使服务器重新启动痛苦。 Bitcask通过存储加速恢复磁盘上每个段的哈希映射的快照，可以更快地加载到内存中。数据库可能随时崩溃，包括将记录附加到日志中途。 Bitcask文件包含校验和，允许检测和忽略日志的这些损坏部分。
<span class="anchor" id="line-67-2"></span>
<span class="anchor" id="line-68-2"></span>由于写操作是以严格顺序的顺序附加到日志中的，所以常见的实现选择是只有一个写入器线程。数据文件段是附加的，否则是不可变的，所以它们可以被多个线程同时读取。
<span class="anchor" id="line-69-2"></span>追加 VS 更新：
<span class="anchor" id="line-70-2"></span>追加和分段合并是顺序写入操作，通常比随机写入快得多，尤其是在磁盘旋转硬盘上。在某种程度上，顺序写入在基于闪存的固态硬盘（SSD）上也是优选的【4】。我们将在第83页的“比较B-树和LSM-树”中进一步讨论这个问题。
<span class="anchor" id="line-71-2"></span>如果段文件是附加的或不可变的，并发和崩溃恢复就简单多了。例如，您不必担心在覆盖值时发生崩溃的情况，而将包含旧值和新值的一部分的文件保留在一起。
<span class="anchor" id="line-72-2"></span>合并旧段可以避免数据文件随着时间的推移而分散的问题。
<span class="anchor" id="line-73-2"></span>
<span class="anchor" id="line-74-2"></span>缺陷：
<span class="anchor" id="line-75-2"></span>散列表必须能放进内存
<span class="anchor" id="line-76-2"></span>如果你有非常多的键，那真是倒霉。原则上可以在磁盘上保留一个哈希映射，不幸的是磁盘哈希映射很难表现优秀。它需要大量的随机访问I/O，当它变满时增长是很昂贵的，并且散列冲突需要很多的逻辑【5】。
<span class="anchor" id="line-77-2"></span>范围查询效率不高。例如，您无法轻松扫描kitty00000和kitty99999之间的所有键——您必须在散列映射中单独查找每个键。
<span class="anchor" id="line-78-2"></span>
<span class="anchor" id="line-79-2"></span>        * SSTables和LSM树
<span class="anchor" id="line-80-2"></span>我们要求键值对的序列按键排序。乍一看，这个要求似乎打破了我们使用顺序写入的能力，但是我们马上就会明白这一点。我们把这个格式称为排序字符串表（Sorted String Table），简称SSTable。求每个键只在每个合并的段文件中出现一次（压缩过程已经保证）
<span class="anchor" id="line-81-2"></span>                * 合并和压缩的过程
<span class="anchor" id="line-82-2"></span>合并段是简单而高效的，即使文件大于可用内存。这种方法就像归并排序算法中使用的方法一样，如图3-4所示：您开始并排读取输入文件，查看每个文件中的第一个键，复制最低键（根据排序顺序）到输出文件，并重复。这产生一个新的合并段文件，也按键排序。
<span class="anchor" id="line-83-1"></span>如果在几个输入段中出现相同的键，该怎么办？请记住，每个段都包含在一段时间内写入数据库的所有值。这意味着一个输入段中的所有值必须比另一个段中的所有值更新（假设我们总是合并相邻的段）。当多个段包含相同的键时，我们可以保留最近段的值，并丢弃旧段中的值      
<span class="anchor" id="line-84-1"></span>为了在文件中找到一个特定的键，你不再需要保存内存中所有键的索引。以图3-5为例：假设你正在内存中寻找键 handiwork，但是你不知道段文件中该关键字的确切偏移量。然而，你知道 handbag 和 handsome 的偏移，而且由于排序特性，你知道 handiwork 必须出现在这两者之间。这意味着您可以跳到 handbag 的偏移位置并从那里扫描，直到您找到 handiwork（或没找到，如果该文件中没有该键）。
<span class="anchor" id="line-85-1"></span>您仍然需要一个内存中索引来告诉您一些键的偏移量，但它可能很稀疏：每几千字节的段文件就有一个键就足够了，因为几千字节可以很快被扫描i。
<span class="anchor" id="line-86-1"></span>
<span class="anchor" id="line-87-1"></span>写入时，将其添加到内存中的平衡树数据结构（例如，红黑树）。这个内存树有时被称为内存表（memtable）。
<span class="anchor" id="line-88-1"></span>当内存表大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入磁盘。这可以高效地完成，因为树已经维护了按键排序的键值对。新的SSTable文件成为数据库的最新部分。当SSTable被写入磁盘时，写入可以继续到一个新的内存表实例。
<span class="anchor" id="line-89-1"></span>为了提供读取请求，首先尝试在内存表中找到关键字，然后在最近的磁盘段中，然后在下一个较旧的段中找到该关键字。
<span class="anchor" id="line-90-1"></span>有时会在后台运行合并和压缩过程以组合段文件并丢弃覆盖或删除的值。
<span class="anchor" id="line-91-1"></span>
<span class="anchor" id="line-92-1"></span>
<span class="anchor" id="line-93-1"></span>        * 如何崩溃恢复
<span class="anchor" id="line-94-1"></span>这个方案效果很好。它只会遇到一个问题：如果数据库崩溃，则最近的写入（在内存表中，但尚未写入磁盘）将丢失。为了避免这个问题，我们可以在磁盘上保存一个单独的日志，每个写入都会立即被附加到磁盘上，就像在前一节中一样。该日志不是按排序顺序，但这并不重要，因为它的唯一目的是在崩溃后恢复内存表。每当内存表写出到SSTable时，相应的日志都可以被丢弃。
<span class="anchor" id="line-95-1"></span>
<span class="anchor" id="line-96-1"></span>        * B 树
<span class="anchor" id="line-97-1"></span>                * 为什么具有 n 个键的B树总是具有 O(log n) 的深度
<span class="anchor" id="line-98-1"></span>                * B 树的存储和查询过程
<span class="anchor" id="line-99-1"></span>                * WAL 是什么？为什么需要WAL
<span class="anchor" id="line-100-1"></span>为了使数据库对崩溃具有韧性，B树实现通常会带有一个额外的磁盘数据结构：预写式日志（WAL, write-ahead-log）（也称为重做日志（redo log））。这是一个仅追加的文件，每个B树修改都可以应用到树本身的页面上。当数据库在崩溃后恢复时，这个日志被用来使B树恢复到一致的状态【5,20】。
<span class="anchor" id="line-101-1"></span>        * 比较B树和LSM树
<span class="anchor" id="line-102-1"></span>LSM树通常能够比B树支持更高的写入吞吐量，部分原因是它们有时具有较低的写放大（尽管这取决于存储引擎配置和工作负载），部分是因为它们顺序地写入紧凑的SSTable文件而不是必须覆盖树中的几个页面【26】。这种差异在磁性硬盘驱动器上尤其重要，顺序写入比随机写入快得多。
<span class="anchor" id="line-103-1"></span>LSM树可以被压缩得更好，因此经常比B树在磁盘上产生更小的文件。 B树存储引擎会由于分割而留下一些未使用的磁盘空间：当页面被拆分或某行不能放入现有页面时，页面中的某些空间仍未被使用。由于LSM树不是面向页面的，并且定期重写SSTables以去除碎片，所以它们具有较低的存储开销，特别是当使用平坦压缩时【
<span class="anchor" id="line-104-1"></span>
<span class="anchor" id="line-105-1"></span>### Redis
<span class="anchor" id="line-106-1"></span>* 数据库
<span class="anchor" id="line-107-1"></span>        * 用到了我们上面讨论的哪些技术？数据模型、查询语言、存储、检索
<span class="anchor" id="line-108-1"></span>        * Redis的过期键删除策略
<span class="anchor" id="line-109-1"></span>        * 为什么说redis是单线程的？服务端单线程怎么和客户端线程池怎么配合？
<span class="anchor" id="line-110-1"></span>}}
<span class="anchor" id="line-111"></span>
<span class="anchor" id="line-112"></span>{{{
<span class="anchor" id="line-113"></span>## 讨论大纲
<span class="anchor" id="line-114"></span>### 基本概念
<span class="anchor" id="line-115"></span>* ACID 的含义
<span class="anchor" id="line-116"></span>* 单对象和多对象操作
<span class="anchor" id="line-117"></span>
<span class="anchor" id="line-118"></span>### 隔离级别
<span class="anchor" id="line-119"></span>#### 弱隔离级别
<span class="anchor" id="line-120"></span>* 读已提交（Read Committed）
<span class="anchor" id="line-121"></span>* 快照隔离和可重复读
<span class="anchor" id="line-122"></span>* 防止丢失更新
<span class="anchor" id="line-123"></span>* 写入偏差与幻读
<span class="anchor" id="line-124"></span>
<span class="anchor" id="line-125"></span>#### 可序列化
<span class="anchor" id="line-126"></span>* 串行执行
<span class="anchor" id="line-127"></span>* 两阶段锁定（2PL）
<span class="anchor" id="line-128"></span>* 序列化快照隔离（SSI Serializable Snapshot Isolation）
<span class="anchor" id="line-129"></span>
<span class="anchor" id="line-130"></span>### Redis 事务处理
<span class="anchor" id="line-131"></span>* Redis 事务的实现
<span class="anchor" id="line-132"></span>* Redis Lua 脚本的执行是否是原子的？
<span class="anchor" id="line-133"></span>* Redis 对 ACID 的支持
<span class="anchor" id="line-134"></span>
<span class="anchor" id="line-135"></span>### MySQL 事务处理
<span class="anchor" id="line-136"></span>* 隔离级别
<span class="anchor" id="line-137"></span>        * 几种隔离级别
<span class="anchor" id="line-138"></span>        * 为什么 RR 为默认隔离级别
<span class="anchor" id="line-139"></span>        * MySQL的 RR 完美的解决了幻读问题吗？如果解决了幻读，还需要SERIALIZABLE？
<span class="anchor" id="line-140"></span>* 锁
<span class="anchor" id="line-141"></span>        * 锁的类型
<span class="anchor" id="line-142"></span>        * CRUD 加什么锁
<span class="anchor" id="line-143"></span>        * 每种隔离级别加什么锁
<span class="anchor" id="line-144"></span>        * 死锁
<span class="anchor" id="line-145"></span>* MVCC
<span class="anchor" id="line-146"></span>* MySQL 事务的实现</pre><span class="anchor" id="line-1166"></span><p class="line874">--- <span class="anchor" id="line-1167"></span><span class="anchor" id="line-1168"></span><span class="anchor" id="line-1169"></span><p class="line867">
<h2 id="Aug_10">Aug 10</h2>
<span class="anchor" id="line-1170"></span><p class="line867">
<h3 id="A.2BWQR0Bk4aUqE-">处理业务</h3>
<span class="anchor" id="line-1171"></span><p class="line874">坑了， 代码先上了测试，没有改数据库。以后先记得把数据库换掉。 <span class="anchor" id="line-1172"></span><span class="anchor" id="line-1173"></span><p class="line867">
<h2 id="Aug_12">Aug 12</h2>
<span class="anchor" id="line-1174"></span><p class="line867">
<h3 id="A.2BUgZeA18PfPt.2B31tmTmA-">分布式系统学习</h3>
<span class="anchor" id="line-1175"></span><p class="line867"><span class="anchor" id="line-1176"></span><span class="anchor" id="line-1177"></span><span class="anchor" id="line-1178"></span><span class="anchor" id="line-1179"></span><span class="anchor" id="line-1180"></span><span class="anchor" id="line-1181"></span><span class="anchor" id="line-1182"></span><span class="anchor" id="line-1183"></span><span class="anchor" id="line-1184"></span><span class="anchor" id="line-1185"></span><span class="anchor" id="line-1186"></span><span class="anchor" id="line-1187"></span><span class="anchor" id="line-1188"></span><span class="anchor" id="line-1189"></span><span class="anchor" id="line-1190"></span><span class="anchor" id="line-1191"></span><span class="anchor" id="line-1192"></span><span class="anchor" id="line-1193"></span><span class="anchor" id="line-1194"></span><span class="anchor" id="line-1195"></span><span class="anchor" id="line-1196"></span><span class="anchor" id="line-1197"></span><span class="anchor" id="line-1198"></span><span class="anchor" id="line-1199"></span><span class="anchor" id="line-1200"></span><span class="anchor" id="line-1201"></span><span class="anchor" id="line-1202"></span><span class="anchor" id="line-1203"></span><span class="anchor" id="line-1204"></span><span class="anchor" id="line-1205"></span><span class="anchor" id="line-1206"></span><span class="anchor" id="line-1207"></span><span class="anchor" id="line-1208"></span><span class="anchor" id="line-1209"></span><span class="anchor" id="line-1210"></span><span class="anchor" id="line-1211"></span><span class="anchor" id="line-1212"></span><span class="anchor" id="line-1213"></span><span class="anchor" id="line-1214"></span><span class="anchor" id="line-1215"></span><span class="anchor" id="line-1216"></span><span class="anchor" id="line-1217"></span><span class="anchor" id="line-1218"></span><span class="anchor" id="line-1219"></span><span class="anchor" id="line-1220"></span><span class="anchor" id="line-1221"></span><span class="anchor" id="line-1222"></span><span class="anchor" id="line-1223"></span><span class="anchor" id="line-1224"></span><span class="anchor" id="line-1225"></span><span class="anchor" id="line-1226"></span><span class="anchor" id="line-1227"></span><pre><span class="anchor" id="line-1-24"></span>### CS 分布式系统带来的优势
<span class="anchor" id="line-2-22"></span> * scalability
<span class="anchor" id="line-3-21"></span>    * performance
<span class="anchor" id="line-4-20"></span>    * availability
<span class="anchor" id="line-5-20"></span> * performance
<span class="anchor" id="line-6-19"></span>
<span class="anchor" id="line-7-19"></span>---
<span class="anchor" id="line-8-18"></span>
<span class="anchor" id="line-9-15"></span>### CS 分布式系统带来的问题
<span class="anchor" id="line-10-14"></span> * number of nodes
<span class="anchor" id="line-11-14"></span> * distance between nodes
<span class="anchor" id="line-12-11"></span> * 可理解性
<span class="anchor" id="line-13-10"></span>
<span class="anchor" id="line-14-10"></span>---
<span class="anchor" id="line-15-9"></span>
<span class="anchor" id="line-16-9"></span>### 为了处理可理解性引入的Abstraction 和 Model
<span class="anchor" id="line-17-9"></span>
<span class="anchor" id="line-18-9"></span>---
<span class="anchor" id="line-19-9"></span>
<span class="anchor" id="line-20-9"></span>### 分布式系统中我们拥有的武器
<span class="anchor" id="line-21-9"></span> * 思想：divide and conquer
<span class="anchor" id="line-22-9"></span> * Partition
<span class="anchor" id="line-23-8"></span> * Replication
<span class="anchor" id="line-24-7"></span>
<span class="anchor" id="line-25-7"></span>---
<span class="anchor" id="line-26-7"></span>
<span class="anchor" id="line-27-7"></span>### 分布式系统抽象与建模详解
<span class="anchor" id="line-28-6"></span> * System Model
<span class="anchor" id="line-29-6"></span>    * node
<span class="anchor" id="line-30-5"></span>    * communication link
<span class="anchor" id="line-31-4"></span>    * over-all assumption
<span class="anchor" id="line-32-4"></span>    * guarantee
<span class="anchor" id="line-33-4"></span>    * Case Study: Consensus Problem, and impossible results
<span class="anchor" id="line-34-4"></span>---
<span class="anchor" id="line-35-4"></span>
<span class="anchor" id="line-36-4"></span>### 常见的Partition技术
<span class="anchor" id="line-37-4"></span> * Partition Of Key-Value Data
<span class="anchor" id="line-38-4"></span> * Partition Of Secondary Indexes
<span class="anchor" id="line-39-4"></span> * Rebalancing Partitions
<span class="anchor" id="line-40-4"></span> * Request Routing
<span class="anchor" id="line-41-4"></span>---
<span class="anchor" id="line-42-4"></span>
<span class="anchor" id="line-43-4"></span>### 常见的Replication技术
<span class="anchor" id="line-44-4"></span> * Single Leader
<span class="anchor" id="line-45-4"></span> * Multi Leader
<span class="anchor" id="line-46-4"></span> * Leaderless
<span class="anchor" id="line-47-4"></span> * Problems of Replication Lag
<span class="anchor" id="line-48-4"></span>---
<span class="anchor" id="line-49-4"></span>
<span class="anchor" id="line-50-4"></span>---</pre><span class="anchor" id="line-1228"></span><span class="anchor" id="line-1229"></span><p class="line867">
<h2 id="Aug_13-14">Aug 13-14</h2>
<span class="anchor" id="line-1230"></span><p class="line867">
<h3 id="A.2BThpSoQ--.2BZvRlsA-lesson_Job">业务-更新lesson Job</h3>
<span class="anchor" id="line-1231"></span><p class="line874">写日志要规范，多参考其他人的代码。 <span class="anchor" id="line-1232"></span>
<h3 id="A.2BTgp.2Bv04aUqE-">上线业务</h3>
<span class="anchor" id="line-1233"></span><p class="line874">先合代码，再release 版本 <span class="anchor" id="line-1234"></span><span class="anchor" id="line-1235"></span><p class="line867">
<h2 id="Aug_15">Aug 15</h2>
<span class="anchor" id="line-1236"></span><p class="line874">scrum会议，月会，写业务，无坑。 公司很有发展前景。 <span class="anchor" id="line-1237"></span><span class="anchor" id="line-1238"></span><p class="line867">
<h2 id="Aug_16">Aug 16</h2>
<span class="anchor" id="line-1239"></span><p class="line867">
<h3 id="A.2BW2ZOYE4AgfRgJ1SMUXGLxnuXbNU-">学习一致性和共识算法</h3>
<span class="anchor" id="line-1240"></span><p class="line867"><span class="anchor" id="line-1241"></span><span class="anchor" id="line-1242"></span><span class="anchor" id="line-1243"></span><span class="anchor" id="line-1244"></span><span class="anchor" id="line-1245"></span><span class="anchor" id="line-1246"></span><span class="anchor" id="line-1247"></span><span class="anchor" id="line-1248"></span><span class="anchor" id="line-1249"></span><span class="anchor" id="line-1250"></span><span class="anchor" id="line-1251"></span><span class="anchor" id="line-1252"></span><span class="anchor" id="line-1253"></span><span class="anchor" id="line-1254"></span><span class="anchor" id="line-1255"></span><span class="anchor" id="line-1256"></span><span class="anchor" id="line-1257"></span><span class="anchor" id="line-1258"></span><span class="anchor" id="line-1259"></span><span class="anchor" id="line-1260"></span><span class="anchor" id="line-1261"></span><span class="anchor" id="line-1262"></span><span class="anchor" id="line-1263"></span><span class="anchor" id="line-1264"></span><span class="anchor" id="line-1265"></span><span class="anchor" id="line-1266"></span><span class="anchor" id="line-1267"></span><span class="anchor" id="line-1268"></span><span class="anchor" id="line-1269"></span><span class="anchor" id="line-1270"></span><span class="anchor" id="line-1271"></span><span class="anchor" id="line-1272"></span><span class="anchor" id="line-1273"></span><span class="anchor" id="line-1274"></span><span class="anchor" id="line-1275"></span><span class="anchor" id="line-1276"></span><span class="anchor" id="line-1277"></span><span class="anchor" id="line-1278"></span><span class="anchor" id="line-1279"></span><span class="anchor" id="line-1280"></span><span class="anchor" id="line-1281"></span><span class="anchor" id="line-1282"></span><span class="anchor" id="line-1283"></span><pre><span class="anchor" id="line-1-25"></span>* Linearizability定义
<span class="anchor" id="line-2-23"></span>    * informal 定义
<span class="anchor" id="line-3-22"></span>    * 读不可flash back
<span class="anchor" id="line-4-21"></span>* 使用Linearizability保证正确性
<span class="anchor" id="line-5-21"></span>    * Locking和选主
<span class="anchor" id="line-6-20"></span>    * 保证约束与唯一性
<span class="anchor" id="line-7-20"></span>    * Cross-Channel方式对timing有依赖
<span class="anchor" id="line-8-19"></span>* 实现Linearizable系统
<span class="anchor" id="line-9-16"></span>    * 常见复制方式是否能实现linearizable system
<span class="anchor" id="line-10-15"></span>    * 解析最难理解场景, leaderless replication下的Quorum不能实现Linearizable原因
<span class="anchor" id="line-11-15"></span>* Linearizability的代价
<span class="anchor" id="line-12-12"></span>    * 先批评一下CAP
<span class="anchor" id="line-13-11"></span>    * Linearizability 与 SystemModel.fault.networkPartition
<span class="anchor" id="line-14-11"></span>    * Linearizability 与 SystemModel.communicationLink.networkDelay
<span class="anchor" id="line-15-10"></span>
<span class="anchor" id="line-16-10"></span>### systemModel.guarantee.ordering
<span class="anchor" id="line-17-10"></span>
<span class="anchor" id="line-18-10"></span>* Ordering 与 Causality
<span class="anchor" id="line-19-10"></span>    * 场景概述Causality
<span class="anchor" id="line-20-10"></span>    * Causal Order是偏序
<span class="anchor" id="line-21-10"></span>    * 比较Linearizable Consistency与 Causal Consistency
<span class="anchor" id="line-22-10"></span>* 捕捉 Causality
<span class="anchor" id="line-23-9"></span>    * Sequence Number Ordering
<span class="anchor" id="line-24-8"></span>    * Lamport timestamps 与其局限性(Uniqueness Problem)
<span class="anchor" id="line-25-8"></span>* Total Order Broadcast
<span class="anchor" id="line-26-8"></span>    * 定义
<span class="anchor" id="line-27-8"></span>    * Linearizability 与 Total-Order-Broadcast
<span class="anchor" id="line-28-7"></span>
<span class="anchor" id="line-29-7"></span>### 分布式事务与Consensus
<span class="anchor" id="line-30-6"></span>* Atomic Commit 与 2PC
<span class="anchor" id="line-31-5"></span>    * 实现
<span class="anchor" id="line-32-5"></span>    * 问题
<span class="anchor" id="line-33-5"></span>    * 变种3PC
<span class="anchor" id="line-34-5"></span>* 实践中的分布式事务
<span class="anchor" id="line-35-5"></span>    * Exactly-once 消息处理
<span class="anchor" id="line-36-5"></span>    * XA
<span class="anchor" id="line-37-5"></span>* Consensus
<span class="anchor" id="line-38-5"></span>    * 定义问题
<span class="anchor" id="line-39-5"></span>    * Consensus与total-order-broadcast的关系
<span class="anchor" id="line-40-5"></span>    * Consensus与single-leader replication的关系
<span class="anchor" id="line-41-5"></span>    * Consensus的局限性
<span class="anchor" id="line-42-5"></span>* 存活检测 与 协调服务</pre><span class="anchor" id="line-1284"></span><span class="anchor" id="line-1285"></span><p class="line867">
<h2 id="Aug_17">Aug 17</h2>
<span class="anchor" id="line-1286"></span><p class="line867">
<h3 id="A.2BU7uWZE7jeAFPnY1W-">去除代码依赖</h3>
<span class="anchor" id="line-1287"></span><p class="line867"><a class="nonexistent" href="/LessonProduct">LessonProduct</a>.productId 改为lesson.productId <span class="anchor" id="line-1288"></span><span class="anchor" id="line-1289"></span><p class="line867">
<h2 id="Aug_19-20">Aug 19-20</h2>
<span class="anchor" id="line-1290"></span><p class="line867">
<h3 id="A.2BZbByWw_.2BbYhgb5YfUhc-">新牛 消息队列</h3>
<span class="anchor" id="line-1291"></span><p class="line867"><span class="anchor" id="line-1292"></span><span class="anchor" id="line-1293"></span><span class="anchor" id="line-1294"></span><span class="anchor" id="line-1295"></span><span class="anchor" id="line-1296"></span><span class="anchor" id="line-1297"></span><span class="anchor" id="line-1298"></span><span class="anchor" id="line-1299"></span><span class="anchor" id="line-1300"></span><span class="anchor" id="line-1301"></span><span class="anchor" id="line-1302"></span><span class="anchor" id="line-1303"></span><span class="anchor" id="line-1304"></span><span class="anchor" id="line-1305"></span><span class="anchor" id="line-1306"></span><span class="anchor" id="line-1307"></span><span class="anchor" id="line-1308"></span><span class="anchor" id="line-1309"></span><span class="anchor" id="line-1310"></span><span class="anchor" id="line-1311"></span><span class="anchor" id="line-1312"></span><span class="anchor" id="line-1313"></span><span class="anchor" id="line-1314"></span><span class="anchor" id="line-1315"></span><span class="anchor" id="line-1316"></span><span class="anchor" id="line-1317"></span><span class="anchor" id="line-1318"></span><span class="anchor" id="line-1319"></span><span class="anchor" id="line-1320"></span><span class="anchor" id="line-1321"></span><span class="anchor" id="line-1322"></span><span class="anchor" id="line-1323"></span><span class="anchor" id="line-1324"></span><span class="anchor" id="line-1325"></span><span class="anchor" id="line-1326"></span><span class="anchor" id="line-1327"></span><span class="anchor" id="line-1328"></span><span class="anchor" id="line-1329"></span><span class="anchor" id="line-1330"></span><span class="anchor" id="line-1331"></span><span class="anchor" id="line-1332"></span><span class="anchor" id="line-1333"></span><span class="anchor" id="line-1334"></span><span class="anchor" id="line-1335"></span><span class="anchor" id="line-1336"></span><span class="anchor" id="line-1337"></span><span class="anchor" id="line-1338"></span><span class="anchor" id="line-1339"></span><span class="anchor" id="line-1340"></span><span class="anchor" id="line-1341"></span><span class="anchor" id="line-1342"></span><span class="anchor" id="line-1343"></span><span class="anchor" id="line-1344"></span><span class="anchor" id="line-1345"></span><span class="anchor" id="line-1346"></span><span class="anchor" id="line-1347"></span><span class="anchor" id="line-1348"></span><span class="anchor" id="line-1349"></span><span class="anchor" id="line-1350"></span><span class="anchor" id="line-1351"></span><span class="anchor" id="line-1352"></span><span class="anchor" id="line-1353"></span><span class="anchor" id="line-1354"></span><span class="anchor" id="line-1355"></span><span class="anchor" id="line-1356"></span><span class="anchor" id="line-1357"></span><span class="anchor" id="line-1358"></span><span class="anchor" id="line-1359"></span><span class="anchor" id="line-1360"></span><span class="anchor" id="line-1361"></span><span class="anchor" id="line-1362"></span><span class="anchor" id="line-1363"></span><span class="anchor" id="line-1364"></span><span class="anchor" id="line-1365"></span><span class="anchor" id="line-1366"></span><span class="anchor" id="line-1367"></span><span class="anchor" id="line-1368"></span><span class="anchor" id="line-1369"></span><span class="anchor" id="line-1370"></span><span class="anchor" id="line-1371"></span><span class="anchor" id="line-1372"></span><span class="anchor" id="line-1373"></span><span class="anchor" id="line-1374"></span><span class="anchor" id="line-1375"></span><span class="anchor" id="line-1376"></span><span class="anchor" id="line-1377"></span><span class="anchor" id="line-1378"></span><span class="anchor" id="line-1379"></span><span class="anchor" id="line-1380"></span><span class="anchor" id="line-1381"></span><span class="anchor" id="line-1382"></span><span class="anchor" id="line-1383"></span><span class="anchor" id="line-1384"></span><span class="anchor" id="line-1385"></span><pre><span class="anchor" id="line-1-26"></span>## 讨论大纲
<span class="anchor" id="line-2-24"></span>### 基本概念
<span class="anchor" id="line-3-23"></span>* 消息中间件/消息队列
<span class="anchor" id="line-4-22"></span>* 松耦合设计、事件驱动架构、流式处理
<span class="anchor" id="line-5-22"></span>* 推模式/拉模式
<span class="anchor" id="line-6-21"></span>* 吞吐量、负载均衡、持久化、可扩展
<span class="anchor" id="line-7-21"></span>
<span class="anchor" id="line-8-20"></span>### 应用场景
<span class="anchor" id="line-9-17"></span>* 场景
<span class="anchor" id="line-10-16"></span>        * 消息没有收到
<span class="anchor" id="line-11-16"></span>        * 我想消息7天内有效，超时清除
<span class="anchor" id="line-12-13"></span>        * 我想业务处理完毕之后，在回ack
<span class="anchor" id="line-13-12"></span>        * 我想发送一个45分钟后投递的消息
<span class="anchor" id="line-14-12"></span>        * 我的消息没人消费了
<span class="anchor" id="line-15-11"></span>        * ...
<span class="anchor" id="line-16-11"></span>
<span class="anchor" id="line-17-11"></span>        * 异步数据交互
<span class="anchor" id="line-18-11"></span>        * 行为跟踪
<span class="anchor" id="line-19-11"></span>        * 日志收集
<span class="anchor" id="line-20-11"></span>        * 流处理
<span class="anchor" id="line-21-11"></span>
<span class="anchor" id="line-22-11"></span>
<span class="anchor" id="line-23-10"></span>* 主流消息中间件
<span class="anchor" id="line-24-9"></span>
<span class="anchor" id="line-25-9"></span>        * activeMQ
<span class="anchor" id="line-26-9"></span>        * rabbitMQ
<span class="anchor" id="line-27-9"></span>        * kafka
<span class="anchor" id="line-28-8"></span>        * rocketMQ
<span class="anchor" id="line-29-8"></span>
<span class="anchor" id="line-30-7"></span>* 消息中间件作用
<span class="anchor" id="line-31-6"></span>
<span class="anchor" id="line-32-6"></span>        * 解耦
<span class="anchor" id="line-33-6"></span>        * 持久化
<span class="anchor" id="line-34-6"></span>        * 削峰
<span class="anchor" id="line-35-6"></span>        * 缓冲
<span class="anchor" id="line-36-6"></span>        * 可恢复
<span class="anchor" id="line-37-6"></span>        * 可扩展
<span class="anchor" id="line-38-6"></span>        * 异步通信
<span class="anchor" id="line-39-6"></span>        * 顺序性
<span class="anchor" id="line-40-6"></span>
<span class="anchor" id="line-41-6"></span>### producer
<span class="anchor" id="line-42-6"></span>#### 序列化
<span class="anchor" id="line-43-5"></span>* protobuf
<span class="anchor" id="line-44-5"></span>* json
<span class="anchor" id="line-45-5"></span>* thrift
<span class="anchor" id="line-46-5"></span>* avro
<span class="anchor" id="line-47-5"></span>* 自定义
<span class="anchor" id="line-48-5"></span>
<span class="anchor" id="line-49-5"></span>#### 发布消息
<span class="anchor" id="line-50-5"></span>* 路由
<span class="anchor" id="line-51-4"></span>* 消息提交
<span class="anchor" id="line-52-4"></span>* 同步发送
<span class="anchor" id="line-53-4"></span>* 异步发送
<span class="anchor" id="line-54-4"></span>* 批量发送
<span class="anchor" id="line-55-4"></span>* 顺序性
<span class="anchor" id="line-56-4"></span>* 超时机制
<span class="anchor" id="line-57-4"></span>* 重试机制
<span class="anchor" id="line-58-4"></span>
<span class="anchor" id="line-59-4"></span>### broker
<span class="anchor" id="line-60-4"></span>* 选举
<span class="anchor" id="line-61-3"></span>
<span class="anchor" id="line-62-3"></span>        * 脑裂
<span class="anchor" id="line-63-3"></span>* 复制
<span class="anchor" id="line-64-3"></span>
<span class="anchor" id="line-65-3"></span>* 物理存储
<span class="anchor" id="line-66-3"></span>
<span class="anchor" id="line-67-3"></span>        * 文件
<span class="anchor" id="line-68-3"></span>        * 索引
<span class="anchor" id="line-69-3"></span>        * 顺序写
<span class="anchor" id="line-70-3"></span>        * 随机读
<span class="anchor" id="line-71-3"></span>
<span class="anchor" id="line-72-3"></span>
<span class="anchor" id="line-73-3"></span>* 消息队列
<span class="anchor" id="line-74-3"></span>
<span class="anchor" id="line-75-3"></span>        * 内存
<span class="anchor" id="line-76-3"></span>        * 磁盘
<span class="anchor" id="line-77-3"></span>        * 惰性队列
<span class="anchor" id="line-78-3"></span>
<span class="anchor" id="line-79-3"></span>
<span class="anchor" id="line-80-3"></span>### consumer
<span class="anchor" id="line-81-3"></span>* 消费组
<span class="anchor" id="line-82-3"></span>* 轮询/长轮询
<span class="anchor" id="line-83-2"></span>* offset
<span class="anchor" id="line-84-2"></span>        * 自动提交
<span class="anchor" id="line-85-2"></span>        * 同步提交
<span class="anchor" id="line-86-2"></span>        * 异步提交
<span class="anchor" id="line-87-2"></span>
<span class="anchor" id="line-88-2"></span>          * 幂等
<span class="anchor" id="line-89-2"></span>        * 组合提交
<span class="anchor" id="line-90-2"></span>* 再均衡
<span class="anchor" id="line-91-2"></span>* 反序列化
<span class="anchor" id="line-92-2"></span>* 消息去重</pre><span class="anchor" id="line-1386"></span><span class="anchor" id="line-1387"></span><p class="line867">
<h2 id="Aug_21">Aug 21</h2>
<span class="anchor" id="line-1388"></span><p class="line867">
<h3 id="tutor-team_.2BTuN4AY.2FBeftOCn6.2F-">tutor-team 代码迁移上线</h3>
<span class="anchor" id="line-1389"></span><span class="anchor" id="line-1390"></span><p class="line867">
<h1 id="A.2BW55OYGA7ftM-">实习总结</h1>
<span class="anchor" id="line-1391"></span><p class="line874">1. 学习tutor-playground 6 天 <span class="anchor" id="line-1392"></span>spring框架构建，采用标准的[三层架构] ， Thrift， Rpc， <a class="nonexistent" href="/RestApi">RestApi</a>， Mysql 存储， 单元测试， Redisson 实现缓存， 主要是数据一致性。 <span class="anchor" id="line-1393"></span><span class="anchor" id="line-1394"></span><p class="line862">2. 增加服务 <a class="nonexistent" href="/AmazeFeedback">AmazeFeedback</a> ， 建表， CRUD操作， Http Api   tutor-atm-user <span class="anchor" id="line-1395"></span><span class="anchor" id="line-1396"></span><p class="line874">3. 写Job 导出用户地址。 tutor-atm-address <span class="anchor" id="line-1397"></span><span class="anchor" id="line-1398"></span><p class="line874">4. 使用消息队列， 班课过期后，随材匹配自动变为暂停推单  tutor-atm-lesson <span class="anchor" id="line-1399"></span><span class="anchor" id="line-1400"></span><p class="line874">5. 更新tutor-at-lesson 线上数据  班课过期后，随材匹配自动变为暂停推单 tutor-atm-lesson <span class="anchor" id="line-1401"></span><span class="anchor" id="line-1402"></span><p class="line874">6. 服务端 - 导出运单列表增加『学生 id』 tutor-inventory-admin <span class="anchor" id="line-1403"></span><span class="anchor" id="line-1404"></span><p class="line874">7. 增加辅导老师带班建议      tutor-atm-user' <span class="anchor" id="line-1405"></span><span class="anchor" id="line-1406"></span><p class="line874">8. 服务端 - LessonVO 增加『剩余名额』 tutor-atm-lesson <span class="anchor" id="line-1407"></span><span class="anchor" id="line-1408"></span><p class="line874">9. 老师好评率数据计算  tutor-atm-user <span class="anchor" id="line-1409"></span><span class="anchor" id="line-1410"></span><p class="line874">10. 服务整理 use tutor-lesson instead of tutor-lesson-admin <span class="anchor" id="line-1411"></span><span class="anchor" id="line-1412"></span><p class="line874">11. 导出学生统计数据 成Excel Tutor-atm-stat <span class="anchor" id="line-1413"></span><span class="anchor" id="line-1414"></span><p class="line874">12. 服务端 - LessonVO 增加『首季用户占比』『首季用户续报率』『非首季用户续报率』 tutor-atm-lesson <span class="anchor" id="line-1415"></span><span class="anchor" id="line-1416"></span><p class="line874">13. 删除Http api tutor-episode-template/material  tutor-atm-lesson <span class="anchor" id="line-1417"></span><span class="anchor" id="line-1418"></span><p class="line874">14. 去掉tutor-mentor-admin 依赖 <span class="anchor" id="line-1419"></span><span class="anchor" id="line-1420"></span><p class="line874">15. 辅导老师身份问题修复  tutor-student-profile tutor-student-episode <span class="anchor" id="line-1421"></span><span class="anchor" id="line-1422"></span><p class="line874">16. 删除项目 tutor-lesson-admin <span class="anchor" id="line-1423"></span><span class="anchor" id="line-1424"></span><p class="line874">17. 修复导入金币Excel 错误  tutor-atm-episode <span class="anchor" id="line-1425"></span><span class="anchor" id="line-1426"></span><p class="line874">18. 整合ACL <span class="anchor" id="line-1427"></span><span class="anchor" id="line-1428"></span><p class="line862">19. 服务整理 <a class="nonexistent" href="/InventoryAdminProxy">InventoryAdminProxy</a> Rpc <span class="anchor" id="line-1429"></span><span class="anchor" id="line-1430"></span><p class="line874">20. inventory query 接口支持 name 模糊匹配 tutor-inventory-admin <span class="anchor" id="line-1431"></span><span class="anchor" id="line-1432"></span><p class="line874">21. tutor-stat 改用 tutor-student-product 提供的接口 <span class="anchor" id="line-1433"></span><span class="anchor" id="line-1434"></span><p class="line874">22. Team资源迁移（三周） <span class="anchor" id="line-1435"></span><span class="anchor" id="line-1436"></span><p class="line874">23. atm-episode 线上导出讨论区日志（支持多个小班） <span class="anchor" id="line-1437"></span><span class="anchor" id="line-1438"></span><p class="line874">24. 班课管理 - 班课支持原价配置 - 服务端(加字段， 加验证逻辑，导入数据刷缓存) <span class="anchor" id="line-1439"></span><span class="anchor" id="line-1440"></span><p class="line874">25. 取消lessonproduct依赖 <span class="anchor" id="line-1441"></span><span class="anchor" id="line-1442"></span><span class="anchor" id="bottom"></span></div>
<div id="pagebottom"></div>
</div>

